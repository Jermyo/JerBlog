[{"title":"VPS搭建SSR服务教程---最全整理","date":"2018-11-27T10:38:26.000Z","path":"2018/11/27/VPS搭建SSR服务教程---最全整理/","text":"教程很简单，整个教程分三步：第一步：购买VPS服务器 第二步：一键部署VPS服务器 第三步：一键加速VPS服务器 （谷歌BBR加速，推荐） 第一步：购买VPS服务器VPS服务器需要选择国外的，这里就不介绍选哪家了，现在类型太多，很多公司为了开辟新市场，很多优惠的方案，有很多一年才5美刀，这个大家自己搜集一下，我用的是 https://clients.hostmybytes.com/clientarea.php 可以百度自己对比不同类型的，有很多，这里不再赘述。 第二步：部署VPS服务器购买服务器后，需要部署一下。因为你买的是虚拟东西，而且又远在国外，我们需要一个叫Xshell的软件来远程部署。Xshell windows版下载地址： 国外云盘1下载 如果你是苹果电脑操作系统，更简单，无需下载xshell，系统可以直接连接VPS。打开终端（Terminal），输入ssh root@ip 其中“ip”替换成你VPS的ip, 按回车键，然后复制粘贴密码，按回车键即可登录。粘贴密码时有可能不显示密码，但不影响， 参考设置方法 如果不能用MAC自带的终端连接的话，直接网上搜“MAC连接SSH的软件”，有很多，然后通过软件来连接vps服务器就行，具体操作方式参考windows xshell。 部署教程： 1、下载xshell软件并安装后，打开软件选择文件，新建随便取个名字，然后把你的服务器ip填上连接国外ip即服务器时，软件会先后提醒你输入用户名和密码，用户名默认都是root，密码是你购买的服务器系统的密码。 如果xshell连不上服务器，没有弹出让你输入用户名和密码的输入框，表明你开到的ip是一个被封的ip，遇到这种情况，重新开新的服务器，直到能用xshell连上为止，耐心点哦！如果同一个地区开了多台服务器还是不行的话，可以换其它地区。 2、一键部署管理脚本连接成功后，会出现如上图所示，之后就可以复制粘贴代码部署了。 CentOS6/Debian6/Ubuntu14 ShadowsocksR一键部署管理脚本： 123456789yum -y install wgetwget -N –no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh备用脚本：yum -y install wgetwget -N –no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 复制上面的代码到VPS服务器里，按回车键，脚本会自动安装，以后只需要运行这个快捷命令就可以出现下图的界面进行设置，快捷管理命令为：bash ssr.sh如上图出现管理界面后，输入数字1来安装SSR服务端。如果输入1后不能进入下一步，那么请退出xshell，重新连接vps服务器，然后输入快捷管理命令bash ssr.sh 再尝试。根据上图提示，依次输入自己想设置的端口和密码 (密码建议用复杂点的字母组合，端口号为40-65535之间的数字)，回车键用于确认 注：关于端口的设置，总的网络总端口有6万多个，理论上可以任意设置。但是有的地区需要设置特殊的端口才有效，一些特殊的端口比如80、143、443、1433、3306、3389、8080。如上图，选择想设置的加密方式，比如10，按回车键确认特别注意，由于iphone端的的wingy目前只支持到cfb，所以我们选择aes-256-cfb接下来是选择协议插件，如下图： 选择并确认后，会出现上图的界面，提示你是否选择兼容原版，这里的原版指的是SS客户端（SS客户端没有协议和混淆的选项），可以根据需求进行选择，演示选择y 之后进行混淆插件的设置。 注意：如果协议是origin，那么混淆也必须是plain；如果协议不是origin，那么混淆可以是任意的。有的地区需要把混淆设置成plain才好用。因为混淆不总是有效果，要看各地区的策略，有时候不混淆（plain）让其看起来像随机数据更好。（特别注意：tls 1.2_ticket_auth容易受到干扰！请选择除tls开头以外的其它混淆！！！）进行混淆插件的设置后，会依次提示你对设备数、单线程限速和端口总限速进行设置，默认值是不进行限制，个人使用的话，选择默认即可，即直接敲回车键。 注意：关于限制设备数，这个协议必须是非原版且不兼容原版才有效，也就是必须使用SSR协议的情况下，才有效！ 之后代码就正式自动部署了，到下图所示的位置，提示你下载文件，输入：y耐心等待一会，出现下面的界面即部署完成：根据上图就可以看到自己设置的SSR账号信息，包括IP、端口、密码、加密方式、协议插件、混淆插件，这些信息需要填入你的SSR客户端。如果之后想修改账号信息，直接输入快捷管理命令：bash ssr.sh 进入管理界面，选择相应的数字来进行一键修改。例如：脚本演示结束。 此脚本是开机自动启动，部署一次即可。最后可以重启服务器确保部署生效（一般情况不重启也可以）。重启需要在命令栏里输入reboot ，输入命令后稍微等待一会服务器就会自动重启，一般重启过程需要2～5分钟，重启过程中Xshell会自动断开连接，等VPS重启好后才可以用Xshell软件进行连接。如果部署过程中卡在某个位置超过10分钟，可以用xshell软件断开，然后重新连接你的ip，再复制代码进行部署。 另：一键部署管理脚本—另一个方式（之前使用过，可行）部署VPS服务器：不多说，直接贴代码1、1wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 2、 1chmod +x shadowsocks.sh 3、 1./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 中间会提示你输入你的SS SERVER的账号，和端口。不输入就是默认。跑完命令后会出来你的SS客户端的信息，图我就不贴了。下面看加密方式特别注意，由于iphone端的的wingy目前只支持到cfb，所以我们选择aes-256-cfb，即7 这一步按回车继续请立即copy下来加以保存。上面的命令全部回车执行后，如果没有报错，即为执行成功，出现确认提示的时候，输入 y 后，回车即可。 安装完成后，脚本提示如下： 1234567Congratulations, shadowsocks install completed!Your Server IP:your_server_ipYour Server Port:your_server_portYour Password:your_passwordYour Local IP:127.0.0.1Your Local Port:1080Your Encryption Method:aes-256-cfb 记录保存好你的上述信息：Server IP、Server Port、Password、Encryption Method这时你的专属ss已经大好了，开始使用吧。 第三步：一键加速VPS服务器此加速教程为谷歌BBR加速,Vultr的服务器框架可以装BBR加速，加速后对速度的提升很明显，所以推荐部署加速脚本。该加速方法是开机自动启动，部署一次就可以了。 按照第二步的步骤，连接服务器ip，登录成功后，在命令栏里粘贴以下代码： 【谷歌BBR加速教程】1234567yum -y install wgetwget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 把上面整个代码复制后粘贴进去，不动的时候按回车，然后耐心等待，最后重启vps服务器即可。 演示开始，如图： 复制并粘贴代码后，按回车键确认如下图提示，按任意键继续部署部署到上图这个位置的时候，等待3～6分钟最后输入y重启服务器，如果输入y提示command not found ，接着输入reboot来重启服务器，确保加速生效，bbr加速脚本是开机自动启动，装一次就可以了。 最近准备新安装一个。发现上面执行安装时，出错，安装不下去，执行以下命令 1wget --no-check-certificate https://freed.ga/github/shadowsocksR.sh; bash shadowsocksR.sh 若提示：wget :command not found请执行：yum install wget -y然后再按照提示走就行了这张图注意保存走到这一步，还有些不够，网速很慢，几乎慢到连不到网，所以进行第三步。 锐速安装一键更换内核脚本（Vultr需先执行此脚本） 1wget -N --no-check-certificate https://freed.ga/kernel/ruisu.sh &amp;&amp; bash ruisu.sh 脚本安装需要1-3分钟，耐心等待服务器重启，服务器重启之后，重新连接继续安装就行了。 锐速安装脚本 (如果找不到相应的 .sh 可以github 上搜索 相应的脚本) 1wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh 另外：重要的事情说三遍！！！锐速不支持Openvz！！！锐速不支持Openvz！！！锐速不支持Openvz！！！出现这些就算大功告成了。电脑连接可查看 上面连接教程就行了 第四步：下载客户端 使用各版本的shadowsocks客户端下载地址可以参考：Android/Windows/iOS/Mac/Linux shadowsocks客户端下载地址（打不开就去github搜，或者直接百度搜下载地址） WIndows客户端配置双击运行shadowsocks.exe，之后会在任务栏有一个小飞机图标，右击小飞机图标，选择服务器-&gt;编辑服务器： 在shadowsocks的windows客户端中，服务器IP指你购买的VPS的IP，服务器端口指你服务器的配置文件中的端口，密码指你服务器的配置文件中的密码，加密指你服务器的配置文件中的加密方式，代理端口默认为1080。其他都可以默认。设置好后，点击添加按钮即可。 MAC OS客户端配置双击运行shadowsocksX-NG.app，之后会在任务栏有一个小飞机图标，右击小飞机图标，选择服务器-&gt;服务器设置：在shadowsocks的Mac OS客户端中，地址指你购买的VPS的IP，冒号后面跟上配置文件中的端口，密码指你服务器的配置文件中的密码，加密指你服务器的配置文件中的加密方式。其他都可以默认。设置好后，点击确认即可。 安卓客户端配置下载apk安装好后，打开影梭客户端，点击主界面左上角的编辑按钮（铅笔形状）：在shadowsocks安卓客户端的配置中填入相应配置信息，其中，功能设置中，路由改成如上图所示，其他都可以默认。 苹果客户端配置shadowsocks苹果客户端经常会被App Store下架，可以在App Store搜索关键字shadowsock或者wingy，找到一个软件截图中包括填写ip，加密方式，密码的软件一般就是对的了（目前可以用的是FirstWingy）。当然，你也可以下载PP助手，之后在PP助手上下载Wingy（Wingy支持）或者shadowrocket（shadowrocket支持）。 总结如上就是手把手教你搭建shadowsocks的全部内容。在国内，***是不允许的了，所以还不如自己搭建ss，可以独享一个线路。","tags":[{"name":"VPS","slug":"VPS","permalink":"https://jermyo.github.io/JerBlog/tags/VPS/"}]},{"title":"使用Node.js快速搭建简单的静态文件服务器","date":"2018-11-14T10:38:26.000Z","path":"2018/11/14/使用Node.js快速搭建简单的静态文件服务器/","text":"前言做前端有时会采用一些复杂框架，在文件系统中直接打开页面（用file:///方式打开），往往会报跨域的错，类似于“XMLHttpRequest cannot load …(文件名). Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https, chrome-extension-resource.”。这时，我们可以快速搭建一个简单的静态文件服务器，用Node.js最合适。 1.在前端项目根目录下创建server.js，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&quot;use strict&quot;;//加载所需要的模块var http = require(&apos;http&apos;);var url = require(&apos;url&apos;);var fs = require(&apos;fs&apos;);var path = require(&apos;path&apos;);var cp = require(&apos;child_process&apos;);//创建服务var httpServer = http.createServer(processRequest);var port = 8080;//指定一个监听的接口httpServer.listen(port, function() &#123; console.log(`app is running at port:$&#123;port&#125;`); console.log(`url: http://localhost:$&#123;port&#125;`); cp.exec(`explorer http://localhost:$&#123;port&#125;`, function () &#123; &#125;);&#125;);//响应请求的函数function processRequest (request, response) &#123; //mime类型 var mime = &#123; &quot;css&quot;: &quot;text/css&quot;, &quot;gif&quot;: &quot;image/gif&quot;, &quot;html&quot;: &quot;text/html&quot;, &quot;ico&quot;: &quot;image/x-icon&quot;, &quot;jpeg&quot;: &quot;image/jpeg&quot;, &quot;jpg&quot;: &quot;image/jpeg&quot;, &quot;js&quot;: &quot;text/javascript&quot;, &quot;json&quot;: &quot;application/json&quot;, &quot;pdf&quot;: &quot;application/pdf&quot;, &quot;png&quot;: &quot;image/png&quot;, &quot;svg&quot;: &quot;image/svg+xml&quot;, &quot;swf&quot;: &quot;application/x-shockwave-flash&quot;, &quot;tiff&quot;: &quot;image/tiff&quot;, &quot;txt&quot;: &quot;text/plain&quot;, &quot;wav&quot;: &quot;audio/x-wav&quot;, &quot;wma&quot;: &quot;audio/x-ms-wma&quot;, &quot;wmv&quot;: &quot;video/x-ms-wmv&quot;, &quot;xml&quot;: &quot;text/xml&quot; &#125;; //request里面切出标识符字符串 var requestUrl = request.url; //url模块的parse方法 接受一个字符串，返回一个url对象,切出来路径 var pathName = url.parse(requestUrl).pathname; //对路径解码，防止中文乱码 var pathName = decodeURI(pathName); //解决301重定向问题，如果pathname没以/结尾，并且没有扩展名 if (!pathName.endsWith(&apos;/&apos;) &amp;&amp; path.extname(pathName) === &apos;&apos;) &#123; pathName += &apos;/&apos;; var redirect = &quot;http://&quot; + request.headers.host + pathName; response.writeHead(301, &#123; location: redirect &#125;); //response.end方法用来回应完成后关闭本次对话，也可以写入HTTP回应的具体内容。 response.end(); &#125; //获取资源文件的绝对路径 var filePath = path.resolve(__dirname + pathName); console.log(filePath); //获取对应文件的文档类型 //我们通过path.extname来获取文件的后缀名。由于extname返回值包含”.”，所以通过slice方法来剔除掉”.”， //对于没有后缀名的文件，我们一律认为是unknown。 var ext = path.extname(pathName); ext = ext ? ext.slice(1) : &apos;unknown&apos;; //未知的类型一律用&quot;text/plain&quot;类型 var contentType = mime[ext] || &quot;text/plain&quot;; fs.stat(filePath, (err, stats) =&gt; &#123; if (err) &#123; response.writeHead(404, &#123; &quot;content-type&quot;: &quot;text/html&quot; &#125;); response.end(&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;); &#125; //没出错 并且文件存在 if (!err &amp;&amp; stats.isFile()) &#123; readFile(filePath, contentType); &#125; //如果路径是目录 if (!err &amp;&amp; stats.isDirectory()) &#123; var html = &quot;&lt;head&gt;&lt;meta charset = &apos;utf-8&apos;/&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&quot;; //读取该路径下文件 fs.readdir(filePath, (err, files) =&gt; &#123; if (err) &#123; console.log(&quot;读取路径失败！&quot;); &#125; else &#123; //做成一个链接表，方便用户访问 var flag = false; for (var file of files) &#123; //如果在目录下找到index.html，直接读取这个文件 if (file === &quot;index.html&quot;) &#123; readFile(filePath + (filePath[filePath.length-1]==&apos;/&apos; ? &apos;&apos; : &apos;/&apos;) + &apos;index.html&apos;, &quot;text/html&quot;); flag = true; break; &#125;; html += `&lt;li&gt;&lt;a href=&apos;$&#123;file&#125;&apos;&gt;$&#123;file&#125;&lt;/a&gt;&lt;/li&gt;`; &#125; if(!flag) &#123; html += &apos;&lt;/ul&gt;&lt;/body&gt;&apos;; response.writeHead(200, &#123; &quot;content-type&quot;: &quot;text/html&quot; &#125;); response.end(html); &#125; &#125; &#125;); &#125; //读取文件的函数 function readFile(filePath, contentType)&#123; response.writeHead(200, &#123; &quot;content-type&quot;: contentType &#125;); //建立流对象，读文件 var stream = fs.createReadStream(filePath); //错误处理 stream.on(&apos;error&apos;, function() &#123; response.writeHead(500, &#123; &quot;content-type&quot;: contentType &#125;); response.end(&quot;&lt;h1&gt;500 Server Error&lt;/h1&gt;&quot;); &#125;); //读取文件 stream.pipe(response); &#125; &#125;);&#125; 2.在前端项目根目录下打开命令提示符或终端，输入以下命令就可以启动小服务器啦。1node server.js","tags":[{"name":"node","slug":"node","permalink":"https://jermyo.github.io/JerBlog/tags/node/"}]},{"title":"你所不知道的console.log()（console.log详解）","date":"2018-11-07T09:14:25.000Z","path":"2018/11/07/你所不知道的console.log()（console.log详解）/","text":"console.log，作为一个前端开发者，想必每天都会用它来做分析调试，但这个简单函数背后你所不知道的一面，很多人未必使用过，有一些也是很方便使用的 基础首先，简单科普这个函数的作用。前端开发者可以在js代码的任何部分调用console.log，然后你就可以在浏览器的开发者控制台里，看到这个函数调用的那一瞬间你指定的变量或表达式的值。 12345678910console.log(&apos;123&apos;);// 123 console.log(&apos;1&apos;, &apos;2&apos;, &apos;3&apos;);// 1 2 3 console.log(&apos;1\\n2\\n3\\n&apos;);// 1// 2// 3 我们可以通过上面的方式进行单个变量（表达式）、多个变量以及换行输出。而这对于日常开发的大多数情况算是够用了。格式化输出12console.log(&apos;%d + %d = %d&apos;, 1, 1, 2);//或console.log(1,1,2);// 1 + 1 = 2 写过C语言的童鞋肯定对上面这种写法不陌生，这种写法在复杂的输出时，能保证模板和数据分离，结构更加清晰。不过简单的输出就不那么方便了。console.log支持的格式标志有:|占位符| 描述 ||–|–|| %s | 字符串 || %d%i | 整数|| %f| 浮点数 || %o/%O | object对象 || %c | css样式 | 常用我就不说了，说一下，不常用的，console.log/debug/warn/error,这些都可以做调试输出，区别是： 样式不同我们可以通过调试器底部筛选出不同的输出项 所以跟网站重构要求html语义化类似，当我们的调试输出比较多时，根据实际场景使用不同类型的输出函数能使我们的输出更有条理。 值得一提的是console.error，我们使用它做输出除了可以输出错误信息外，还可以输出调用这个函数的一瞬间的调用栈！这无疑给我们调试带来很多方便（当然你也可以用js断点一步步跟踪），而这是console.log所不具备的。除了console.error，还有一个函数console.trace也可以打印出调用一瞬间的调用栈，不过它的输出样式和位置就跟console.log一样了： 其实除了打印调试信息外，console还有不少强大有用但却很低调的接口。 console.time &amp; console.timeEnd这是性能调试的利器啊，熟悉NodeJs的童鞋更是清楚。肯定不少童鞋干过这事：在我们的某块代码前新增一个类似startTime的变量，给它一个时间戳，然后在我们执行完代码后，再打一个时间戳，再将两者相减，再将结果输出。现在我们使用上面的函数，就可以省下很多功夫了： 12345console.time(&apos;wait&apos;);setTimeOut(()=&gt;&#123; console.timeEnd(&apos;wait&apos;);&#125;,1000);wait: 1000ms 使用这两个接口是何其方便！而且我们还可以将一个字符串作为函数参数，来区分不同的性能计时。 console.count这是一个计数器，我们可以传个名字给它，如a，然后每次调用console.count(‘a’)（可以在不同函数不同地方），它就能打印出这样一个调用执行了多少次：12345678910111213let a = ()=&gt;&#123; console.count(&apos;Call function a&apos;);&#125;;let b = ()=&gt;&#123; a();&#125;let c = ()=&gt;&#123; b();&#125;b();c();Call function a:1Call function b:2 这个函数特别适用于在一些复杂的场景，有时一个函数被多个地方调用到，而我们想知道该函数是否少调用或重复调用，此时使用计数器比js断点自己还要默记调了几次快多了。 console.assertassert，搞编程的应该对这个单词不陌生：断言。使用console.assert，你可以理解为于禁的技能（三国杀玩多了这孩子），你猜错了这个表达式的真假，那我就可以打出我的信息： 123456let a = ()=&gt;&#123; let el = document.getElementById(&apos;test&apos;); console.assert(el,&apos;没有ID为test的节点&apos;);&#125;a();// Assertion failed: 没有ID为test的节点 不消说，使用该函数可以让我们在某些地方只在符合某个条件才进行调试输出，使输出更加干净。当然你也可以用if语句，不过写起来就麻烦了一些。 console.group一看就知道是分组输出：12345678console.group(&apos;group1&apos;);console.log(&apos;a&apos;);console.log(&apos;b&apos;);console.groupEnd(&apos;group1&apos;);console.group(&apos;group2&apos;);console.log(&apos;a2&apos;);console.log(&apos;b2&apos;);console.groupEnd(&apos;group2&apos;); 显然这个函数特别适合有一大堆调试输出的情况，做大项目估计会用上。不过有时你打开控制台看到满屏满屏的输出你也会很头痛的，于是你可以分组输出且默认收起： console.clear最后的最后，该清场了。 特别适用于，在一个多人开发项目，你不爽别人的调试输出，那你可以用这个函数统统清掉，再输出自己的调试信息，不用跟这个函数客气。 总结我是王大锤，万万没想到，console.log的八卦就这样被我说完了，本以为还可以吹水个几万字。 附conssole.timestamp &amp; console.profile这两个函数对应chrome调试面板的两个tab，调试性能时可用上，有兴趣的童鞋可以看看：Google开发者文档之console","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jermyo.github.io/JerBlog/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://jermyo.github.io/JerBlog/tags/github/"}]},{"title":"关于html中table表格tr,td的高度和宽度","date":"2018-10-30T12:52:47.000Z","path":"2018/10/30/关于html中table表格tr,td的高度和宽度/","text":"关于html中table表格tr,td的高度和宽度做网页的时候经常会遇到各种各样的问题，经常遇到的一个就是会碰到表格宽度对不齐的问题。首先，来分析一下这三个标签中height和width的区别： 1、table中的width和height设置及其作用：table中设置的height其实是设置一个最小值，也就是当表格中的内容或者行高总值超过这个设置值时，会自动延长表格的height值，当表格中的内容或者行高没有达到这个值时，会自动扩大到这个值。 table中设置的width值一般为表格宽度的最大值，不能改变，即使内部的内容宽度超过也不能改变。（这个内部内容如果是图片的话是可以改变表格宽度的。） 2、tr标签中width和height设置及其作用：tr标签里面的width设置不起任何作用，因为从第一点可以看出，表格的width是不能改变的，tr标签当然就不起作用了。 所以在tr中只有讨论height设置的可能了，tr中的height设置和几个tr之间的设置有关。 当几个tr都设置了height的具体数值时，各个tr的height按照设置的值的比例来分配总的height值，注意这里说的是总的height值。 当几个tr都没有设置height具体值时，平均分配总的height值。 当有的tr设置了具体的数值，有的没有设置具体的数值为默认时，先保证各个tr的基本需要，剩下的再满足设置了具体值的tr，之后再全部给没有设置具体值的tr。 最后一种情况还要考虑总的宽度不够tr总的设置值的情况，不够的话要满足tr的基本需要，这里会自动延长表格的height的。然后再考虑设置了height的tr，最后考虑没有设置height的tr。 3、td标签中width和height设置及其作用：td标签里面的width和height都是起作用的。先看td的width吧，某一个td的width是和所处的一列每个td的width都相关的，取其中最大的width作为这一列中每个td的width，一定要从全局把握某个td的width，不能从这一个的width设置就断言它的宽度就是多少，这样是不准确的。 当我们把每一列的宽度都弄清楚之后，事情就好办了。这时候各个td之间的宽度分配按照第二条中各tr的height分配规律， 有一点不同的是全部是默认的情况下，各td的width不是平均分配，而是根据各自的实际内容按比例分配。 再看看td的height设置吧，各个td的height要看这个td所在的行的最大高度来确定这一行的每个td的height，然后各个行的高度情况和tr中的height分配原则是一样的。 还有一点要注意，就是td的height和tr的height之间的关系。首先肯定是根据内容的需要，在这个基础上，再根据设置的值来确定，哪个设置的值大就按照哪个，如果一个设置了值一个没有设置值，那么按照设置值的算。","tags":[{"name":"布局","slug":"布局","permalink":"https://jermyo.github.io/JerBlog/tags/布局/"}]},{"title":"vue移动端项目，屏幕适配方法，rem","date":"2018-10-16T12:25:33.000Z","path":"2018/10/16/vue移动端项目，屏幕适配方法，rem/","text":"亲测有效，大家可以试试。 使用的是vue-cli搭建的webpack项目，然后按步骤一步一步走下去就成功了 1.终端中输入1npm i lib-flexible --save 2.终端中输入1npm i px2rem-loader --save-dev 3.在项目入口文件 main.js 里 引入 lib-flexible1import &apos;lib-flexible&apos; 4.在项目根目录的 index.html 中添加如下 meta1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 5.在build文件夹下的util.js中添加1234567891011121314// utils.jsvar cssLoader = &#123; loader: &apos;css-loader&apos;, options: &#123; minimize: process.env.NODE_ENV === &apos;production&apos;, sourceMap: options.sourceMap &#125;&#125;var px2remLoader = &#123; loader: &apos;px2rem-loader&apos;, options: &#123; remUnit: 75 &#125;&#125; 并放进generateLoaders函数的 loaders 数组中123function generateLoaders(loader, loaderOptions) &#123; var loaders = [cssLoader, px2remLoader]&#125; 6.重新在终端中输入 npm run dev 即可PS：以上实现转换适用于：（1）组件中编写的下的css （2）从index.js或者main.js中import ‘../../static/css/reset.css’引入css （3）在组件的&lt;script type=”text/ecmascript-6″&gt; import ‘../../static/css/reset.css’中引入css 另外的情况不适用： （1）组件中@import “../../static/css/reset.css (可考虑上面（2）、（3）的形式引入) （2）外部样式:&lt;link rel=”stylesheet” href=”static/css/reset.css”&gt; （3）元素内部样式：style=”height: 417px; width: 550px;” 补充另外我要补充的是：在做移动端适配的时候我们不建议给字体也设置rem的单位，针对这种情况，我为字体适配的解决方案是使用媒体查询，文件以组件中@import “../../static/css/reset.css形式引入，可完美解决移动端适配问题 更多详情请戳 传送门","tags":[{"name":"vue","slug":"vue","permalink":"https://jermyo.github.io/JerBlog/tags/vue/"},{"name":"移动端","slug":"移动端","permalink":"https://jermyo.github.io/JerBlog/tags/移动端/"}]},{"title":"Hexo使用畅言评论系统","date":"2018-10-13T15:25:33.000Z","path":"2018/10/13/Hexo使用畅言评论系统/","text":"一、前言作为一个博客网站，怎么能没有跟各位互动呢，而github是一个纯静态的网页博客，无法设置评论，所以就只有用其它网站的插件了。听网上说之前githubpage很多人的评论系统是用的多说，不过最近多说网站关闭，导致很多人没有办法使用评论，而友言又因为是http协议不支持https的github博客,别担心，还有一个替代品，那就是畅言 二、注册登录畅言网上搜索畅言，可以直接传送门：http://changyan.kuaizhan.com/ 注册完成后还会有一大堆初始化，有个需要注意的地方，畅言是需要备案的，不备案会有15天的试用期，现在我们不管，点击下图标注的地方，后面我会介绍怎么通过备案。其它可以参考我写的。 三、插入代码接下来就是代码的插入了，我用的是yelee的主题，所以就用这个作为例子。 在\\themes\\hexo-theme-yelee\\layout_partial\\comments文件夹下建立一个changyan.ejs的文件，文件里的代码参考在你畅言的管理页有。 git bash123456789&lt;!--PC版--&gt;&lt;div id=\"SOHUCS\" &gt;&lt;/div&gt;&lt;script charset=\"utf-8\" type=\"text/javascript\" src=\"https://changyan.sohu.com/upload/changyan.js\" &gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;window.changyan.api.config(&#123;appid: '***',conf: '***''&#125;);&lt;/script&gt; 这是我畅言网站建议我的代码git bash12345678910111213&lt;section class=\"changyan\" id=\"comments\"&gt; &lt;div id=\"SOHUCS\"&gt;&lt;/div&gt; &lt;script charset=\"utf-8\" type=\"text/javascript\" src=\"https://changyan.sohu.com/upload/changyan.js\" &gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var loadComment = function()&#123; window.changyan.api.config(&#123; appid: '**appid**', conf: '**appkey**' &#125;); &#125; &lt;/script&gt; &lt;%- partial('click2show') %&gt;&lt;/section&gt; 大家参考我写的代码和网站示例代码，这里其实大家可以参考你们主题里面其它评论里面的代码，根据主题不同可以做变动，大家有不懂的地方可以给我发邮箱，我一定及时给你们答复。 在article.ejs里面添加一句代码，下面高亮部分就是我加的代码git bash123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;article id=\"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;\" class=\"article article-type-&lt;%= post.layout %&gt;\" itemscope itemprop=\"blogPost\"&gt; &lt;%if(post.noDate != \"true\")&#123;%&gt; &lt;div class=\"article-meta\"&gt; &lt;%- partial('post/date', &#123;class_name: 'article-date', date_format: null&#125;) %&gt; &lt;/div&gt; &lt;%&#125;%&gt; &lt;div class=\"article-inner\"&gt; &lt;% if (theme.fancybox)&#123; %&gt; &lt;input type=\"hidden\" class=\"isFancy\" /&gt; &lt;% &#125; %&gt; &lt;% if (post.link || post.title)&#123; %&gt; &lt;header class=\"article-header\"&gt; &lt;%- partial('post/title', &#123;class_name: 'article-title'&#125;) %&gt; &lt;/header&gt; &lt;% if (!index)&#123; %&gt; &lt;div class=\"article-info article-info-post\"&gt; &lt;%- partial('post/category') %&gt; &lt;%- partial('post/tag') %&gt; &lt;div class=\"clearfix\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;div class=\"article-entry\" itemprop=\"articleBody\"&gt; &lt;% if (index &amp;&amp; (post.description || post.excerpt))&#123; %&gt; &lt;% if (post.description)&#123; %&gt; &lt;%- post.description %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- post.excerpt %&gt; &lt;% &#125; %&gt; &lt;% &#125; else &#123; %&gt; &lt;% if (is_page())&#123; %&gt; &lt;%- partial('_partial/page') %&gt; &lt;% &#125; %&gt; &lt;%- post.content %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;% if (index)&#123; %&gt; &lt;div class=\"article-info article-info-index\"&gt; &lt;%if(post.top)&#123;%&gt; &lt;div class=\"article-pop-out tagcloud\"&gt; &lt;a class=\"\"&gt;置顶&lt;/a&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;%- partial('post/category') %&gt; &lt;%- partial('post/tag') %&gt; &lt;% if (index &amp;&amp; (post.description || post.excerpt))&#123; %&gt; &lt;p class=\"article-more-link\"&gt; &lt;a href=\"&lt;%- url_for(post.path) %&gt;#more\"&gt;&lt;%= __('index.more') %&gt; &gt;&gt;&lt;/a&gt; &lt;/p&gt; &lt;% &#125; %&gt; &lt;div class=\"clearfix\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;% if (!index)&#123; %&gt; &lt;%- partial('post/nav') %&gt; &lt;% &#125; %&gt;&lt;/article&gt;&lt;%- partial('_partial/toc') %&gt;&lt;% if (!index &amp;&amp; theme.share.on &amp;&amp; (post.share != false || post.share))&#123; %&gt; &lt;%- partial('post/share') %&gt;&lt;% &#125; %&gt;&lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;% if (theme.duoshuo.on) &#123; %&gt; &lt;%- partial('comments/duoshuo', &#123; key: post.path, title: post.title, url: config.url+url_for(post.path), &#125;) %&gt; &lt;% &#125; else if (theme.youyan.on) &#123; %&gt; &lt;%- partial('comments/youyan') %&gt; &lt;% &#125; else if (theme.disqus.on) &#123; %&gt; &lt;%- partial('comments/disqus', &#123; shortname: theme.disqus.shortname &#125;) %&gt; &lt;% &#125; else if (config.disqus_shortname) &#123; %&gt; &lt;%- partial('comments/disqus', &#123; shortname: config.disqus_shortname &#125;) %&gt; &lt;% &#125; %&gt; #下面这四行代码就是我加的代码 &lt;%else if (theme.changyan.on) &#123; %&gt; &lt;%- partial('comments/changyan', &#123; &#125;) %&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt;&lt;%- partial('_partial/post-nav-button') %&gt;&lt;% if (!index) &#123; %&gt; &lt;script&gt; &lt;% if (post.fancybox === false)&#123; %&gt; yiliaConfig.fancybox = false; &lt;% &#125; %&gt; &lt;/script&gt;&lt;% &#125; %&gt; 我就加了这几行代码 git bash1234&lt;%else if (theme.changyan.on) &#123; %&gt; &lt;%- partial('comments/changyan', &#123; &#125;) %&gt; &lt;% &#125; %&gt; 其中theme.changyan.on是在主题的_config.yml文件中配置，comments/changyan是添加文件的位置。 在主题的config.yml 文件中加git bash12changyan: on: true 当然，我们要把文件中的preload_comment: 配成ture。 git bash1preload_comment: true 此时，我们对畅言插件的添加就完成了一大半了。如果你畅言中的地址写对，应该在页面可以看到效果了。 四、畅言的备案前面也提到，畅言是需要备案的，但是如果我们搭建个个人网站还得去买域名买空间备案，那也太得不偿失了。下面我教大家用一个方法忽略备案。 我们需要一个已经备案的网站域名和备案号，这个大家可以去网上百度。可以找一个小众的网站域名，去备案查询网查询备案号。 然后在畅言后台系统 系统设置-通用设置添加备案号和站点网址，注意站点网址一定要改。 重点来了，备案地址没有写我们自己的网站域名我们的博客是用不了评论系统的，这个时候我们只需要把我们的域名地址写入域名白名单就行了。 做到这样，差不多就完成了。如果大家遇到什么问题，可以联系我的email，也可以在评论区写下你的评论，我会第一时间回复大家。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jermyo.github.io/JerBlog/tags/hexo/"},{"name":"畅言","slug":"畅言","permalink":"https://jermyo.github.io/JerBlog/tags/畅言/"}]},{"title":"Hello World","date":"2018-10-12T06:53:23.641Z","path":"2018/10/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"BlueLake博客主题的详细配置","date":"2016-12-29T03:25:33.000Z","path":"2016/12/29/BlueLake博客主题的详细配置/","text":"开始之前BlueLake主题写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。 在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。 1. 安装您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。 1.1 安装主题在根目录下打开终端窗口：git bash1$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 1.2 安装主题渲染器BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。git bash12$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 1.3 启用主题打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。根_config.yml_config.yml1theme: BlueLake 1.4 验证首先启动 Hexo 本地站点，并开启调试模式：git bash1$ hexo s --debug 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 1.5 更新主题今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。git bash12cd themes/BlueLakegit pull 2. 配置2.1 配置网站头部显示文字打开根_config.yml，找到：根_config.yml_config.yml1234title: subtitle: description: author: title和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。 2.2 设置语言该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：根_config.yml_config.yml1language: zh-CN 2.3 设置菜单打开主题_config.yml，找到：主题_config.ymlthemes/BlueLake/_config.yml12345678910111213menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive # - page: about # directory: about/ # icon: fa-user - page: rss directory: atom.xml icon: fa-rss 主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好：主题_config.ymlthemes/BlueLake/_config.yml12345# About page about: email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 github_url: ## github主页链接地址 2.3.1 添加about页此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：git bash1$ hexo new page 'about' 打开主题_config.yml，补全关于我页面的详细信息：主题_config.ymlthemes/BlueLake/_config.yml12345678# About page about: photo_url: ## 头像的链接地址 email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 weibo_name: ## 微博用户名 github_url: ## github主页链接地址 github_name: ## github用户名 当然您也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好。 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件在根目录下打开命令行窗口：git bash123$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 添加主题_config.yml配置：主题_config.ymlthemes/BlueLake/_config.yml1234567891011121314Plugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemapfeed: type: atom path: atom.xml limit: 20sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 2.4 添加本地搜索默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件：git bash1$ npm install hexo-generator-json-content@2.2.0 --save 然后在根_config.yml添加配置：根_config.yml_config.yml123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 最后在主题_config.yml添加配置：主题_config.ymlthemes/BlueLake/_config.yml1local_search: true 2.5 修改站点图标站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。(有很多网站都可以在线生成ico格式的图片。) 2.6 添加站点关键字请在hexo目录的根_config.yml中添加keywords字段，如：根_config.yml_config.yml1234567# Sitetitle: Hexosubtitle: 副标题description: 网站简要描述,如：Charles·Zheng's blog.keywords: 网站关键字, key, key1, key2, key3author: Charleslanguage: zh-CN 2.7 其他配置主题_config.yml的其他配置 show_category_count——是否显示分类下的文章数。 widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。主题_config.ymlthemes/BlueLake/_config.yml 12show_category_count: true widgets_on_small_screens: true 3.集成第三方服务3.1 添加评论目前主题集成六种第三方评论，分别是多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了，在国内目前网易云跟帖和畅言还不错。 注册并获得代码。 若使用多说评论，注册多说后获得short_name。 若使用Disqus评论，注册Disqus后获得short_name。 若使用来必力评论，注册来必力,获得data-uid。 若使用友言评论，注册友言,获得uid。 若使用网易云跟帖评论，注册网易云跟帖,获得productKey。 若使用畅言评论，注册畅言，获得appid，appkey。 配置主题_config.yml：主题_config.ymlthemes/BlueLake/_config.yml12345678910#Cmmentscomment: duoshuo: ## duoshuo_shortname disqus: ## disqus_shortname livere: ## 来必力(data-uid) uyan: ## 友言(uid) cloudTie: ## 网易云跟帖(productKey) changyan: ## 畅言需在下方配置两个参数，此处不填。 appid: ## 畅言(appid) appkey: ##畅言(appkey) 3.2 百度统计 登录百度统计，定位到站点的代码获取页面。 复制//hm.baidu.com/hm.js?后面那串统计脚本id(假设为：8006843039519956000) 配置主题_config.yml:主题_config.ymlthemes/BlueLake/_config.yml 1baidu_analytics: 8006843039519956000 注意： baidu_analytics不是你的百度id或者百度统计id如若使用谷歌统计，配置方法与百度统计类似。 3.3 卜算子阅读次数统计主题_config.ymlthemes/BlueLake/_config.yml1busuanzi: true 若设置为true将计算文章的阅读量(Hits)，并显示在文章标题下的小手图标旁。 3.4 微博秀微博秀挂件的代码放在layout/_widget/weibo.jade下，需要您去微博开放平台获取您自己的微博秀代码来替换。 登录微博开放平台，选择微博秀。 为了与主题风格统一，作如下配置 基础设置：高400px；勾选宽度自适应；颜色选择白色； 样式设置：主字色#333；链接色#40759b；鼠标悬停色#f7f8f8； 模块设置：去掉标题、边框、粉丝的勾选框，只留微博。 复制代码里src=&quot;&quot;里引号包裹的内容，替换到layout/_widget/weibo.jadeweibo.jadelayout/_widget/weibo.jade1234.widget .widget-title i(class='fa fa-weibo')= ' ' + __('新浪微博') iframe(width=\"100%\",height=\"400\",class=\"share_self\",frameborder=\"0\",scrolling=\"no\",src=\"http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1\") 这只是为了和主题的风格统一，当然您也可以自由随意发挥。 注意：最主要是是要把src里uid=和verifier=后面的字段替换为您自己代码里的就好。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jermyo.github.io/JerBlog/tags/hexo/"},{"name":"BlueLake","slug":"BlueLake","permalink":"https://jermyo.github.io/JerBlog/tags/BlueLake/"}]},{"title":"自定义HEXO站内搜索Javascript+json","date":"2016-11-09T01:24:56.000Z","path":"2016/11/09/自定义HEXO站内搜索Javascript-json/","text":"开始之前目前很多Hexo博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源： hexo-generator-search生成xml格式的数据文件。 hexo-generator-json-content 生成json格式的数据文件。今天的主角是hexo-generator-json-content，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。 1.安装1$ npm install hexo-generator-json-content@2.2.0 --save 然后执行hexo generate时会自动生成content.json文件，若使用默认设置，生成的数据结构如下123456789101112131415161718192021222324252627282930313233343536373839404142434445meta: &#123; title: hexo.config.title, subtitle: hexo.config.subtitle, description: hexo.config.description, author: hexo.config.author, url: hexo.config.url&#125;,pages: [&#123; //-&gt; all pages title: page.title, slug: page.slug, date: page.date, updated: page.updated, comments: page.comments, permalink: page.permalink, path: page.path, excerpt: page.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: page.content, //-&gt; only text minified ;) raw: page.raw, //-&gt; original MD content content: page.content //-&gt; final HTML content&#125;],posts: [&#123; //-&gt; only published posts title: post.title, slug: post.slug, date: post.date, updated: post.updated, comments: post.comments, permalink: post.permalink, path: post.path, excerpt: post.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: post.content, //-&gt; only text minified ;) raw: post.raw, //-&gt; original MD content content: post.content, //-&gt; final HTML content categories: [&#123; name: category.name, slug: category.slug, permalink: category.permalink &#125;], tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;]&#125;] 2.配置hexo-generator-json-content默认生成的json数据内容非常全，默认配置如下：123456789101112131415161718192021222324252627282930313233jsonContent: meta: true keywords: false # (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish) pages: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: true # but only if root keywords option language was set text: true raw: false content: false posts: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: true # but only if root keywords option language was set text: true raw: false content: false categories: true tags: true 因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在hexo/_config.yml中加入：123456789101112131415161718jsonContent: meta: false pages: false posts: title: true #文章标题 date: true #发表日期 path: true #路径 text: true #文本字段 raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true #标签 这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。例如：1234567891011&#123; \"title\": \"自定义HEXO站内搜索Javascript+json\", \"date\": \"2016-11-09T01:24:56.000Z\", \"path\": \"2016/11/09/自定义HEXO站内搜索Javascript-json.html\", \"text\": \"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\", \"tags\": [&#123; \"name\": \"javascript,hexo\", \"slug\": \"javascript-hexo\", \"permalink\": \"http://chaoo.oschina.io/tags/javascript-hexo/\" &#125;]&#125; 3.JavaScript实现代码接下来就是用JS实现查询方法并把结果渲染到页面。 3.1 xhr加载数据12345678910111213141516171819202122var searchData;function loadData(success) &#123; if (!searchData) &#123; var xhr = new XMLHttpRequest(); xhr.open('GET', '/content.json', true); xhr.onload = function() &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) &#123; var res = JSON.parse(this.response || this.responseText); searchData = res instanceof Array ? res : res.posts; success(searchData); &#125; else &#123; console.error(this.statusText); &#125; &#125;; xhr.onerror = function() &#123; console.error(this.statusText); &#125;; xhr.send(); &#125; else &#123; success(searchData); &#125;&#125; 3.2 匹配文章内容返回结果12345678910function matcher(post, regExp) &#123; // 匹配优先级：title &gt; tags &gt; text return regtest(post.title, regExp) || post.tags.some(function(tag) &#123; return regtest(tag.name, regExp); &#125;) || regtest(post.text, regExp);&#125;function regtest(raw, regExp) &#123; regExp.lastIndex = 0; return regExp.test(raw);&#125; 3.3 结果渲染到页面123456789101112131415function render(data) &#123; var html = ''; if (data.length) &#123; html = data.map(function(post) &#123; return tpl(searchTpl, &#123; title: post.title, path: post.path, date: new Date(post.date).toLocaleDateString(), tags: post.tags.map(function(tag) &#123; return '&lt;span&gt;' + tag.name + '&lt;/span&gt;'; &#125;).join('') &#125;); &#125;).join(''); &#125; &#125; 3.3 查询匹配1234567891011function search(key) &#123; // 关键字 =&gt; 正则，空格隔开的看作多个关键字 // a b c =&gt; /a|b|c/gmi var regExp = new RegExp(key.replace(/[ ]/g, '|'), 'gmi'); loadData(function(data) &#123; var result = data.filter(function(post) &#123; return matcher(post, regExp); &#125;); render(result); &#125;);&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jermyo.github.io/JerBlog/tags/hexo/"},{"name":"javascript","slug":"javascript","permalink":"https://jermyo.github.io/JerBlog/tags/javascript/"}]},{"title":"github博客迁移","date":"2016-08-17T03:14:25.000Z","path":"2016/08/17/github博客迁移/","text":"由于github博客在国内访问非常慢而且经常不稳定，百度爬虫也无法抓取github博客内容，所以决定将博客迁移至码云。 1.迁移代码把代码从github迁移至码云（oschina）。首先，你要先在码云注册一个账号，和GitHub操作基本一样，这里不再赘述。码云的Pages服务基本和GitHub的一样，不过码云的Pages服务更灵活一些。在GitHub上，可以新建一个以用户名命名的仓库，将网站代码放在master分支下，即可自动部署到：http://用户名.github.io/，若其他命名的仓库则新建一个gh-pages的分支，网站代码放在gh-pages下，，即可自动部署到：http://用户名.github.io/仓库名/。对于码云，基本和GitHub一样，不过还需要手动开启Pages服务，而且其他仓库虽然默认在osc-pages下，但可自定到自己喜欢的分支上。代码迁移步骤如下： 1.1 新建码云项目以我自己的博客为例，项目地址：https://github.com/chaooo/chaooo.github.io.git。它在Github上的Pages地址是：http://chaooo.github.io如果想把它转移到码云Pages，只需要登录你的码云账户，点击右上角的+号，选择新建项目: 1.2 开启pages服务然后点击创建，项目会在后台自动导入，导入成功后，点击菜单栏的Pages,码云默认的Pages服务分支是osc-pages，但是你也已选择自己静态页面所在的分支，这里我的博客项目的静态页面分支是master，选择master并点击启动服务。至此，博客已经部署成功，访问提供的地址：http://chaoo.oschina.io即可查看到我的博客。 2.修改hexo配置打开博客根目录的_config.yml文件，找到：12345678910# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://chaooo.github.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/chaooo/chaooo.github.io.git branch: master 修改为(根据自己的仓库地址修改)：1234567891011121314# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'#url: http://chaooo.github.iourl: http://chaoo.oschina.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:#- type: git# repository: https://github.com/chaooo/chaooo.github.io.git# branch: master- type: git repository: https://git.oschina.net/chaoo/chaoo.git branch: master 然后执行下面命令，以重新生成baidusitemap.xml。1hexo generate -d 3.验证网站百度搜索引擎入口：百度搜索引擎入口。先添加域名，然后验证网站，这里统一都使用文件验证，就是下载对应的html文件，放到域名根目录下，也就收博客根目录下的public/下面 。然后部署到服务器,输入地址：http://chaoo.oschina.io/baidu_verify_wjJ25Q3cv2.html能访问到就可以点验证按钮(按照百度的引导步骤就好)。 4.sitemap提交直接点击sitemap填写数据文件地址：http://chaoo.oschina.io/baidusitemap.xml,输入验证码提交。 自动推送自动推送很简单，就是在你代码里面嵌入自动推送JS代码，在页面被访问时，页面URL将立即被推送给百度，可将代码添加到\\themes\\landscape\\layout\\_partial\\after_footer.ejs中的最下面就行。代码如下：1234567891011121314&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; 这样就可以等待百度收录了。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jermyo.github.io/JerBlog/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://jermyo.github.io/JerBlog/tags/github/"}]},{"title":"好用的Web包管理器-Bower","date":"2016-08-12T07:32:41.000Z","path":"2016/08/12/Web包管理器-Bower/","text":"Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。 开始之前在安装bower之前，必须确认你已经安装了Node.js和Git。 1.安装Bower使用npm，打开终端，键入：1npm install -g bower #全局安装bower 移步这里查看不同平台上安装的问题。 2.使用Bower使用help命令查看帮助。12345678910111213141516171819202122232425262728293031323334bower helpUsage: bower &lt;command&gt; [&lt;args&gt;] [&lt;options&gt;]Commands: cache Manage bower cache help Display help information about Bower home Opens a package homepage into your favorite browser info Info of a particular package init Interactively create a bower.json file install Install a package locally link Symlink a package folder list List local packages - and possible updates login Authenticate with GitHub and store credentials lookup Look up a package URL by name prune Removes local extraneous packages register Register a package search Search for a package by name update Update a local package uninstall Remove a local package unregister Remove a package from the registry version Bump a package versionOptions: -f, --force Makes various commands more forceful -j, --json Output consumable JSON -l, --loglevel What level of logs to report -o, --offline Do not hit the network -q, --quiet Only output important information -s, --silent Do not output anything, besides errors -V, --verbose Makes output more verbose --allow-root Allows running commands as root -v, --version Output Bower version --no-color Disable colorsSee 'bower help &lt;command&gt;' for more information on a specific command. 3.安装包到本地通过命令bower install安装软件包默认到bower_components/目录。1bower install &lt;package&gt; #package为包名 想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它.12345bower install # 通过 bower.json 文件安装bower install jquery # 通过在github上注册的包名安装bower install desandro/masonry # GitHub短链接bower install git://github.com/user/package.git # Github上的 .gitbower install http://example.com/script.js # URL 安装选项12345-F, --force-latest: Force latest version on conflict-p, --production: Do not install project devDependencies-S, --save: Save installed packages into the project’s bower.json dependencies-D, --save-dev: Save installed packages into the project’s bower.json devDependencies-E, --save-exact: Configure installed packages with an exact version rather than semver 4.用bower.json文件来管理依赖发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行bower install就可根据bower.json来安装依赖的包。在项目中执行1bower init 会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上--save即可。 5.使用下载好的包对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：12&lt;link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\"&gt;&lt;script type=\"text/javascript\" src=\"bower_components/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt; 6.更新包若下载的包升级了，只需执行update命令即可更新，例如：1bower update jquery 这样就可以自动升级到最新版的jquery了。更新选项1234-F, --force-latest: Force latest version on conflict-p, --production: Do not install project devDependencies-S, --save: Update dependencies in bower.json-D, --save-dev: Update devDependencies in bower.json 7.搜索包12bower search #搜索所有包bower search &lt;packageName&gt; #搜索指定名称的包 或者可以在这里:https://bower.io/search/搜索喜欢的包. 8.卸载包1bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;] 卸载选项12-S, --save: Remove uninstalled packages from the project’s bower.json dependencies-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies","tags":[{"name":"bower","slug":"bower","permalink":"https://jermyo.github.io/JerBlog/tags/bower/"}]},{"title":"Node.js RESTful API(16)","date":"2016-06-30T03:38:20.000Z","path":"2016/06/30/Node.js RESTful API/","text":"16、Node.js RESTful API */REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。 表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。 HTTP 方法以下为 REST 基本架构的四个方法：1234GET - 用于获取数据。PUT - 用于添加数据。DELETE - 用于删除数据。POST - 用于更新或添加数据。 创建 RESTful首先，创建一个 json 数据资源文件 users.json，内容如下：1234567891011121314151617181920&#123; \"user1\" : &#123; \"name\" : \"mahesh\", \"password\" : \"password1\", \"profession\" : \"teacher\", \"id\": 1 &#125;, \"user2\" : &#123; \"name\" : \"suresh\", \"password\" : \"password2\", \"profession\" : \"librarian\", \"id\": 2 &#125;, \"user3\" : &#123; \"name\" : \"ramesh\", \"password\" : \"password3\", \"profession\" : \"clerk\", \"id\": 3 &#125;&#125; 基于以上数据，我们创建以下 RESTful API：12345序号 URI HTTP方法 发送内容 结果 1 listUsers GET 空 显示所有用户列表 2 addUser POST JSON 字符串 添加新用户 3 deleteUser DELETE JSON 字符串 删除用户 4 :id GET 空 显示用户详细信息 获取用户列表：listUsers创建 RESTful API listUsers，用于读取用户的信息列表， server.js 文件代码如下所示：1234567891011121314var express = require('express');var app = express();var fs = require('fs');app.get('./listUsers', function (req, res)&#123; fs.readFile(__dirname + \"/\" + \"users.Json\", 'utf8', function (err, data)&#123; console.log(data); res.end(data); &#125;);&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;); 接下来执行以下命令：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/listUsers，结果如下所示：1234567891011121314151617181920&#123; \"user1\" : &#123; \"name\" : \"mahesh\", \"password\" : \"password1\", \"profession\" : \"teacher\", \"id\": 1 &#125;, \"user2\" : &#123; \"name\" : \"suresh\", \"password\" : \"password2\", \"profession\" : \"librarian\", \"id\": 2 &#125;, \"user3\" : &#123; \"name\" : \"ramesh\", \"password\" : \"password3\", \"profession\" : \"clerk\", \"id\": 3 &#125;&#125; 添加用户：addUser创建 RESTful API addUser， 用于添加新的用户数据，server.js 文件代码如下所示：1234567891011121314151617181920212223242526var express = require('express');var app = express();var fs = require('fs');//添加的新用户数据var user = &#123; \"user4\" : &#123; \"name\" : \"mohit\", \"password\" : \"password4\", \"profession\" : \"teacher\", \"id\": 4 &#125;&#125;;app.get('./addUser', function (req, res)&#123; //读取已存在的数据 fs.readFile(__dirname + \"/\" + \"users.Json\", 'utf8', function (err, data)&#123; data = JSON.parse(data); data[\"user4\"] = user[\"user4\"]; console.log(data); res.end(JSON.stringify(data)); &#125;);&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;); 接下来执行以下命令：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/addUser，结果如下所示：123456789101112131415161718192021&#123; user1: &#123; name: 'mahesh', password: 'password1', profession: 'teacher', id: 1 &#125;, user2: &#123; name: 'suresh', password: 'password2', profession: 'librarian', id: 2 &#125;, user3: &#123; name: 'ramesh', password: 'password3', profession: 'clerk', id: 3 &#125;, user4: &#123; name: 'mohit', password: 'password4', profession: 'teacher', id: 4 &#125; &#125; 删除用户：deleteUser创建 RESTful API deleteUser， 用于删除指定用户的详细信息，以下实例中，用户 id 为 2，server.js 文件代码如下所示：1234567891011121314151617var express = require('express');var app = express();var fs = require('fs');app.get('./deleteUser', function (req, res)&#123; //读取已存在的数据 fs.readFile(__dirname + \"/\" + \"users.Json\", 'utf8', function (err, data)&#123; data = JSON.parse(data); delete data[\"user\"+2]; console.log(data); res.end(JSON.stringify(data)); &#125;);&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;); 接下来执行以下命令：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/deleteUser，结果如下所示：1234567891011&#123; user1: &#123; name: 'mahesh', password: 'password1', profession: 'teacher', id: 1 &#125;, user3: &#123; name: 'ramesh', password: 'password3', profession: 'clerk', id: 3 &#125;,&#125; 显示用户详情：:id(用户id)创建 RESTful API :id（用户id）， 用于读取指定用户的详细信息，server.js 文件代码如下所示：1234567891011121314151617var express = require('express');var app = express();var fs = require('fs');app.get('./:id', function (req, res)&#123; //读取已存在的数据 fs.readFile(__dirname + \"/\" + \"users.Json\", 'utf8', function (err, data)&#123; data = JSON.parse(data); var user = data[\"user\" + req.params.id] console.log(user); res.end(JSON.stringify(user)); &#125;);&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;); 接下来执行以下命令：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/2，结果如下所示：123456&#123; \"name\":\"suresh\", \"password\":\"password2\", \"profession\":\"librarian\", \"id\":2&#125;","tags":[{"name":"node","slug":"node","permalink":"https://jermyo.github.io/JerBlog/tags/node/"}]},{"title":"Node.js Express 框架(15)","date":"2016-06-30T01:38:20.000Z","path":"2016/06/30/Node.js Express 框架/","text":"15、Node.js Express 框架Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。Express 框架核心特性：1、可以设置中间件来响应 HTTP 请求。2、定义了路由表用于执行不同的 HTTP 请求动作。3、可以通过向模板传递参数来动态渲染 HTML 页面。 安装 Express安装 Express 并将其保存到依赖列表中：1npm install express --save 以上命令会将 Express 框架安装在当期目录的 node_modules 目录中， node_modules 目录下会自动创建 express 目录。以下几个重要的模块是需要与 express 框架一起安装的：123456//body-parser - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。//cookie-parser - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。//multer - node.js 中间件，用于处理 enctype=&quot;multipart/form-data&quot;（设置表单的MIME编码）的表单数据。 npm install body-parser --save npm install cookie-parser --save npm install multer --save 第一个 Express 框架实例接下来我们使用 Express 框架来输出 “Hello World”。以下实例中我们引入了 express 模块，并在客户端发起请求后，响应 “Hello World” 字符串。创建 express_demo.js 文件，代码如下所示：12345678910var express = require('express');var app = express();app.get('/', function (req,res)&#123; res.send('Hello World');&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port);&#125;); 执行以上代码：12node express_demo.js应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081，结果如下所示：1Hello World 请求和响应Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。 Request 对象request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：req.app：当callback为外部文件时，用req.app访问express的实例req.baseUrl：获取路由当前安装的URL路径req.body / req.cookies：获得「请求主体」/ Cookiesreq.fresh / req.stale：判断请求是否还「新鲜」req.hostname / req.ip：获取主机名和IP地址req.originalUrl：获取原始请求URLreq.params：获取路由的parametersreq.path：获取请求路径req.protocol：获取协议类型req.query：获取URL的查询参数串req.route：获取当前匹配的路由req.subdomains：获取子域名req.accpets（）：检查请求的Accept头的请求类型req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguagesreq.get（）：获取指定的HTTP请求头req.is（）：判断请求头Content-Type的MIME类型 Response 对象response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：res.app：同req.app一样res.append（）：追加指定HTTP头res.set（）在res.append（）后将重置之前设置的头res.cookie（name，value [，option]）：设置Cookieopition: domain / expires / httpOnly / maxAge / path / secure / signedres.clearCookie（）：清除Cookieres.download（）：传送指定路径的文件res.get（）：返回指定的HTTP头res.json（）：传送JSON响应res.jsonp（）：传送JSONP响应res.location（）：只设置响应的Location HTTP头，不设置状态码或者close responseres.redirect（）：设置响应的Location HTTP头，并且设置状态码302res.send（）：传送HTTP响应res.sendFile（path [，options] [，fn]）：传送指定路径的文件 -会自动根据文件extension设定Content-Typeres.set（）：设置HTTP头，传入object可以一次设置多个头res.status（）：设置HTTP状态码res.type（）：设置Content-Type的MIME类型 路由我们已经了解了 HTTP 请求的基本应用，而路由决定了由谁(指定脚本)去响应客户端请求。在HTTP请求中，我们可以通过路由提取出请求的URL以及GET/POST参数。接下来我们扩展 Hello World，添加一些功能来处理更多类型的 HTTP 请求。创建 express_demo2.js 文件，代码如下所示：1234567891011121314151617181920212223242526272829303132var express = require('express');var app = express();//主页输出\"Hello World\"app.get('/', function (req, res)&#123; console.log(\"主页GET请求\"); res.send('Hello GET');&#125;);//POST请求app.post('/', function (req, res)&#123; console.log(\"主页 POST 请求\"); res.send('Hello POST');&#125;);// /del_user页面响应app.delete('/del_user', function (req, res)&#123; console.log(\"/del_user响应 DELETE 请求\"); res.send('删除页面');&#125;);// /list_user 页面 GET 请求app.get('/list_user', function (req, res)&#123; console.log(\"/list_user 页面 GET 请求\"); res.send('用户列表页面');&#125;);// 对页面 abcd, abxcd, ab123cd, 等响应GET请求app.get('/ab*cd', function (req, res)&#123; console.log(\"/ab*cd GET 请求\"); res.send('正则匹配')&#125;);var server = app.listen(8081,function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port);&#125;); 执行以上代码：1234567891011 node express_demo2.js 应用实例，访问地址为 http://0.0.0.0:8081``` 接下来你可以尝试访问 http://127.0.0.1:8081 不同的地址，查看效果。 访问 http://127.0.0.1:8081/list_user 结果：用户列表页 访问 http://127.0.0.1:8081/abcd 结果：正则匹配 访问 http://127.0.0.1:8081/abcdefg 结果：Cannot GET/abcdefg 无法解析该地址#### 静态文件Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写：``` javascript app.use(express.static(&apos;public&apos;));//public为放置静态文件的目录 我们可以到 public/images 目录下放些图片,如下所示：12345node_modulesserver.jspublic/public/imagespublic/images/logo.png 让我们再修改下 “Hello Word” 应用添加处理静态文件的功能。创建 express_demo3.js 文件，代码如下所示：1234567891011var express = require('express');var app = express();app.use(express.static('public'));app.get('/', function (req, res)&#123; res.send('Hello World');&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port);&#125;) 执行以上代码：12node express_demo3.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/images/logo.png ,结果展示了图片。 GET 方法以下实例演示了在表单中通过 GET 方法提交两个参数，我们可以使用 server.js 文件内的 process_get 路由器来处理输入：index.htm 文件代码如下：123456789&lt;html&gt; &lt;body&gt; &lt;form action=\"http://127.0.0.1:8081/process_get\" method=\"GET\"&gt; First Name:&lt;input type=\"text\" name=\"first_name\"&gt;&lt;br&gt; Last Name: &lt;input type=\"text\" name=\"last_name\"&gt; &lt;input type=\"submit\" name=\"Submit\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; server.js文件：1234567891011121314151617181920var express = require('express');var app = express();app.use(express.static('public'));app.get('/index.htm', function (req, res)&#123; res.sendFile(__dirname + \"/\" + \"index.htm\");&#125;);app.get('/process_get', function (req, res)&#123; //输出JSON格式 response = &#123; first_name:req.query.first_name, last_name:req.query.last_name &#125;; console.log(response); res.end(JSON.stringify(response));&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port); &#125;); 执行以上代码：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 浏览器访问 http://127.0.0.1:8081/index.htm,填写表单aaa,bbb，然后提交，结果： {&quot;first_name&quot;:&quot;aaa&quot;,&quot;last_name&quot;:&quot;bbb&quot;} POST 方法以下实例演示了在表单中通过 POST 方法提交两个参数，我们可以使用 server.js 文件内的 process_get 路由器来处理输入：index.htm 文件代码修改如下：123456789&lt;html&gt; &lt;body&gt; &lt;form action=\"http://127.0.0.1:8081/process_post\" method=\"POST\"&gt; First Name: &lt;input type=\"text\" name=\"first_name\"&gt;&lt;br&gt; Last Name: &lt;input type=\"text\" name=\"last_name\"&gt; &lt;input type=\"submit\" value=\"Submit\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; server.js 文件代码修改如下:1234567891011121314151617181920212223var express = require('express');var app = express();var bodyParser = require('body-parser');//创建application/x-www-form-urlencode编码解析var urlencodedParser = bodyParser.urlencoded(&#123;extended:false&#125;);app.use(express.static('public'));app.get('/index.htm', function (req, res) &#123; res.sendFile(__dirname + \"/\" + \"index.htm\");&#125;);app.post('/process_post', urlencodedParser, function (req, res)&#123; //输出 JSON 格式 response = &#123; first_name:req.body.first_name, last_name:req.body.last_name &#125;; console.log(response); res.end(JSON.stringify(response));&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port); &#125;); 执行以上代码：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 浏览器访问 http://127.0.0.1:8081/index.htm,填写表单aaa,bbb，然后提交，结果： {&quot;first_name&quot;:&quot;aaa&quot;,&quot;last_name&quot;:&quot;bbb&quot;} 文件上传以下我们创建一个用于上传文件的表单，使用 POST 方法，表单 enctype 属性设置为 multipart/form-data。index.htm 文件代码修改如下：12345678910111213&lt;html&gt; &lt;head&gt; &lt;title&gt;文件上传表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;文件上传：&lt;/h3&gt; 选择一个文件上传: &lt;br /&gt; &lt;form action=\"/file_upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"image\" size=\"50\" /&gt;&lt;br /&gt; &lt;input type=\"submit\" value=\"上传文件\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; server.js 文件代码修改如下:12345678910111213141516171819202122232425262728293031323334var express = require('express');var app = express();var fs = require(\"fs\");var bodyParser = require('body-parser');var multer = require('multer');app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.use(multer(&#123;dest:'/tmp/'&#125;).array('image'));app.get('/index.htm', function (req, res) &#123; res.sendFile(__dirname + \"/\" + \"index.htm\");&#125;);app.post('/file_upload', function (req, res) &#123; console.log(req.files[0]);//上传文件信息 var des_file = __dirname + \"/\" + req.files[0].originalname; fs.readFile(req. files[0].path, function (err, data) &#123; fs.writeFile(des_file, data, function (err) &#123; if (err) &#123; console.log(err); &#125; else&#123; response = &#123; message:'File uploaded successfully', filename:req.files[0].originalname &#125;; &#125;; console.log(response); res.end(JSON.stringify(response)); &#125;); &#125;);&#125;);var server = app.listen(8081,function() &#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port);&#125;); 执行以上代码：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 浏览器访问 http://127.0.0.1:8081/index.htm,上传本地文件a.jpg，结果： {&quot;message&quot;:&quot;File uploaded successfully&quot;,&quot;filename&quot;:&quot;a.jpg&quot;} Cookie 管理我们可以使用中间件向 Node.js 服务器发送 cookie 信息，以下代码输出了客户端发送的 cookie 信息：express_cookie.js文件12345678var express = require('express');var cookieParser = require('cookie-parser');var app = express();app.use(cookieParser());app.get('/', function (req, res) &#123; console.log(\"Cookies: \", req.cookies);&#125;);app.listen(8081);","tags":[{"name":"node","slug":"node","permalink":"https://jermyo.github.io/JerBlog/tags/node/"}]},{"title":"Node.js Web 模块(14)","date":"2016-06-29T12:51:36.000Z","path":"2016/06/29/Node.js Web模块/","text":"14、Node.js Web 模块使用 Node 创建 Web 服务器Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下：1var http = require('http'); 以下是演示一个最基本的 HTTP 服务器架构(使用8081端口)，创建 server.js 文件，代码如下所示：123456789101112131415161718192021222324252627var http = require('http');var fs = require('fs');var url = require('url');//创建服务器http.createServer(function(request,response)&#123; //解析请求，包括文件名 var pathname = url.parse(request.url).pathname; //输出请求文件名 console.log(\"Request for \" + pathname + \" received.\"); //从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1), function (err, data)&#123; if (err) &#123; console.log(err); //HTTP 状态码：404：NOT FOUND //Content Type：text/plain response.writeHead(404, &#123;'Content-Type': 'text/html'&#125;); &#125; else&#123; //HTTP 状态码：200：OK //Content Type：text/plain response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); //响应文件内容 response.write(data.toString()); &#125;; //发送响应数据 response.end(); &#125;);&#125;).listen(8081); 控制台会输出以下信息1console.log('Server running at http://127.0.0.1:8081/'); 接下来我们在该目录下创建一个 index.htm 文件，代码如下：12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;Sample Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello World!&lt;/body&gt;&lt;/html&gt; 执行 server.js 文件：12node server.jsServer running at http://127.0.0.1:8081/ 使用 Node 创建 Web 客户端Node 创建 Web 客户端需要引入 http 模块，创建 client.js 文件，代码如下所示：12345678910111213141516171819202122var http = require('http');//用于请求选项var optionss = &#123; host:'localhost', port:'8081' path:'/index.htm'&#125;;//处理响应的回调函数var callback = function(response)&#123; //不断更新数据 var body = ''; response.on('data', function(data)&#123; body += data; &#125;); response.on('end', function()&#123; //数据接收完成 console.log(body); &#125;);&#125;//向服务器端发送请求var req = http.request(options, callback);req.end(); 新开一个终端，执行 client.js 文件，输出结果如下：1node client.js 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello World! &lt;/body&gt;&lt;/html&gt; 执行 server.js 的控制台输出信息如下：12Server running at http://127.0.0.1:8081/Request for /index.htm received. # 客户端请求信息","tags":[{"name":"node","slug":"node","permalink":"https://jermyo.github.io/JerBlog/tags/node/"}]},{"title":"Node.js 工具模块(13)","date":"2016-06-29T10:38:26.000Z","path":"2016/06/29/Node.js 工具模块/","text":"13、Node.js 工具模块Node.js OS 模块Node.js os 模块提供了一些基本的系统操作函数。我们可以通过以下方式引入该模块：1var os = require(\"os\"); 方法：1 os.tmpdir()//返回操作系统的默认临时文件夹。2 os.endianness()//返回 CPU 的字节序，可能的是 “BE” 或 “LE”。3 os.hostname()//返回操作系统的主机名。4 os.type()//返回操作系统名5 os.platform()//返回操作系统名6 os.arch()//返回操作系统 CPU 架构，可能的值有 “x64”、”arm” 和 “ia32”。7 os.release()//返回操作系统的发行版本。8 os.uptime()//返回操作系统运行的时间，以秒为单位。9 os.loadavg()//返回一个包含 1、5、15 分钟平均负载的数组。10 os.totalmem()//返回系统内存总量，单位为字节。11 os.freemem()//返回操作系统空闲内存量，单位是字节。12 os.cpus()//返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。13 os.networkInterfaces()//获得网络接口列表。 属性：os.EOL//定义了操作系统的行尾符的常量。实例创建 main.js 文件，代码如下所示：123456var os = require(\"os\");console.log('endianness : ' + os.endianness());// CPU 的字节序console.log('type : ' + os.type());// 操作系统名console.log('platform : ' + os.platform());// 操作系统名console.log('total memory : ' + os.totalmem() + \" bytes.\");// 系统内存总量console.log('free memory : ' + os.freemem() + \" bytes.\");// 操作系统空闲内存量 代码执行结果如下：123456node main.js endianness : LEtype : Linuxplatform : linuxtotal memory : 25103400960 bytes.free memory : 20676710400 bytes. Node.js Path 模块Node.js path 模块提供了一些用于处理文件路径的小工具，我们可以通过以下方式引入该模块：1var path = require(\"path\"); 方法1 path.normalize(p)//规范化路径，注意’..’ 和 ‘.’。2 path.join([path1][, path2][, ...])//用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\\”。3 path.resolve([from ...], to)//将 to 参数解析为绝对路径。4 path.isAbsolute(path)//判断参数 path 是否是绝对路径。5 path.relative(from, to)//用于将相对路径转为绝对路径。6 path.dirname(p)//返回路径中代表文件夹的部分，同 Unix 的dirname 命令类似。7 path.basename(p[, ext])//返回路径中的最后一部分。同 Unix 命令 bashname 类似。8 path.extname(p)//返回路径中文件的后缀名，即路径中最后一个’.’之后的部分。如果一个路径中并不包含’.’或该路径只包含一个’.’ 且这个’.’为路径的第一个字符，则此命令返回空字符串。9 path.parse(pathString)//返回路径字符串的对象。10 path.format(pathObject)//从对象中返回路径字符串，和 path.parse 相反。 属性1 path.sep//平台的文件路径分隔符，’\\‘ 或 ‘/‘。2 path.delimiter//平台的分隔符, ; or ‘:’.3 path.posix//提供上述 path 的方法，不过总是以 posix 兼容的方式交互。4 path.win32//提供上述 path 的方法，不过总是以 win32 兼容的方式交互。 实例创建 main.js 文件，代码如下所示：123456789var path = require(\"path\");// 格式化路径console.log('normalization : ' + path.normalize('/test/test1//2slashes/1slash/tab/..'));// 连接路径console.log('joint path : ' + path.join('/test', 'test1', '2slashes/1slash', 'tab', '..'));// 转换为绝对路径console.log('resolve : ' + path.resolve('main.js'));// 路径中文件的后缀名console.log('ext name : ' + path.extname('main.js')); 代码执行结果如下：12345node main.js normalization : /test/test1/2slashes/1slashjoint path : /test/test1/2slashes/1slashresolve : /web/com/1427176256_27423/main.jsext name : .js Node.js Net 模块Node.js Net 模块提供了一些用于底层的网络通信的小工具，包含了创建服务器/客户端的方法，我们可以通过以下方式引入该模块：1var net = require(\"net\") 方法：1 net.createServer([options][, connectionListener])//创建一个 TCP 服务器。参数 connectionListener 自动给 ‘connection’ 事件创建监听器。2 net.connect(options[, connectionListener])//返回一个新的 ‘net.Socket’，并连接到指定的地址和端口。当 socket 建立的时候，将会触发 ‘connect’ 事件。3 net.createConnection(options[, connectionListener])//创建一个到端口 port 和 主机 host的 TCP 连接。 host 默认为 ‘localhost’。4 net.connect(port[, host][, connectListener])//创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。5 net.createConnection(port[, host][, connectListener])//创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。6 net.connect(path[, connectListener])//创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件上。返回 ‘net.Socket’。7 net.createConnection(path[, connectListener])//创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。8 net.isIP(input)//检测输入的是否为 IP 地址。 IPV4 返回 4， IPV6 返回 6，其他情况返回 0。9 net.isIPv4(input)//如果输入的地址为 IPV4， 返回 true，否则返回 false。10 net.isIPv6(input)//如果输入的地址为 IPV6， 返回 true，否则返回 false。 net.Servernet.Server通常用于创建一个 TCP 或本地服务器。 net.Server方法：1 server.listen(port[, host][, backlog][, callback])//监听指定端口 port 和 主机 host ac连接。 默认情况下 host 接受任何 IPv4 地址(INADDR_ANY)的直接连接。端口 port 为 0 时，则会分配一个随机端口。2 server.listen(path[, callback])//通过指定 path 的连接，启动一个本地 socket 服务器。3 server.listen(handle[, callback])//通过指定句柄连接。4 server.listen(options[, callback])//options 的属性：端口 port, 主机 host, 和 backlog, 以及可选参数 callback 函数, 他们在一起调用server.listen(port, [host], [backlog], [callback])。还有，参数 path 可以用来指定 UNIX socket。5 server.close([callback])//服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发 ‘close’ 事件。6 server.address()//操作系统返回绑定的地址，协议族名和服务器端口。7 server.unref()//如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。8 server.ref()//与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。9 server.getConnections(callback)//异步获取服务器当前活跃连接的数量。当 socket 发送给子进程后才有效；回调函数有 2 个参数 err 和 count。 net.Server事件：1 listening//当服务器调用 server.listen 绑定后会触发。2 connection//当新连接创建后会被触发。socket 是 net.Socket实例。3 close//服务器关闭时会触发。注意，如果存在连接，这个事件不会被触发直到所有的连接关闭。4 error//发生错误时触发。’close’ 事件将被下列事件直接调用。 net.Socketnet.Socket 对象是 TCP 或 UNIX Socket 的抽象。net.Socket 实例实现了一个双工流接口。 他们可以在用户创建客户端(使用 connect())时使用, 或者由 Node 创建它们，并通过 connection 服务器事件传递给用户。 net.Socket事件：1 lookup//在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。2 connect//成功建立 socket 连接时触发。3 data//当接收到数据时触发。4 end//当 socket 另一端发送 FIN 包时，触发该事件。5 timeout//当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。6 drain//当写缓存为空得时候触发。可用来控制上传。7 error//错误发生时触发。8 close//当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。 net.Socket属性：1 socket.bufferSize//该属性显示了要写入缓冲区的字节数。2 socket.remoteAddress//远程的 IP 地址字符串，例如：’74.125.127.100’ or ‘2001:4860:a005::68’。3 socket.remoteFamily//远程IP协议族字符串，比如 ‘IPv4’ or ‘IPv6’。4 socket.remotePort//远程端口，数字表示，例如：80 or 21。5 socket.localAddress//网络连接绑定的本地接口 远程客户端正在连接的本地 IP 地址，字符串表示。例如，如果你在监听’0.0.0.0’而客户端连接在’192.168.1.1’，这个值就会是 ‘192.168.1.1’。6 socket.localPort//本地端口地址，数字表示。例如：80 or 21。7 socket.bytesRead//接收到得字节数。8 socket.bytesWritten//发送的字节数。 net.Socket方法：1 new net.Socket([options])//构造一个新的 socket 对象。2 socket.connect(port[, host][, connectListener])//指定端口 port 和 主机 host，创建 socket 连接 。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。3 socket.connect(path[, connectListener])//打开指定路径的 unix socket。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。4 socket.setEncoding([encoding])//设置编码5 socket.write(data[, encoding][, callback])//在 socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。6 socket.end([data][, encoding])//半关闭 socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。7 socket.destroy()//确保没有 I/O 活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。8 socket.pause()//暂停读取数据。就是说，不会再触发 data 事件。对于控制上传非常有用。9 socket.resume()//调用 pause() 后想恢复读取数据。10 socket.setTimeout(timeout[, callback])//socket 闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。11 socket.setNoDelay([noDelay])//禁用纳格（Nagle）算法。默认情况下 TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用 socket.write() 时立即发送数据。noDelay 默认值为 true。12 socket.setKeepAlive([enable][, initialDelay])//禁用/启用长连接功能，并在发送第一个在闲置 socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay （毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay 设为0，将会保留默认（或者之前）的值。默认值为0.13 socket.address()//操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有 3 个属性，比如{ port: 12346, family: ‘IPv4’, address: ‘127.0.0.1’ }。14 socket.unref()//如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。15 socket.ref()//与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。 实例创建 server.js 文件，代码如下所示：123456789101112var net = require('net');var server = net.createServer(function(connection)&#123; console.log('client connected'); connection.on('end', function()&#123; console.log('客户端关闭连接'); &#125;); connection.write('Hello World!\\r\\n'); connection.pipe(connection);&#125;);server.listen(8080,function()&#123; console.log('server is listening');&#125;); 执行以上服务端代码：12node server.jsserver is listening # 服务已创建并监听8080端口 新开一个窗口，创建client.js文件，代码如下：1234567891011var net = require('net');var client = net.connect(&#123;port: 8080&#125;,function()&#123; console.log('连接服务器！');&#125;);client.on('data', function(data)&#123; console.log(data.toString()); client.end();&#125;);client.on('end',function()&#123; console.log('断开与服务器的连接');&#125;); 执行以上客户端的代码：123连接服务器！Hello World!断开与服务器的连接 Node.js DNS 模块Node.js DNS 模块用于解析域名。引入 DNS 模块语法格式如下：1var dns = require(\"dns\") 方法：1 dns.lookup(hostname[, options], callback)//将域名（比如 ‘runoob.com’）解析为第一条找到的记录 A （IPV4）或 AAAA(IPV6)。参数 options可以是一个对象或整数。如果没有提供 options，IP v4 和 v6 地址都可以。如果 options 是整数，则必须是 4 或 6。2 dns.lookupService(address, port, callback)//使用 getnameinfo 解析传入的地址和端口为域名和服务。3 dns.resolve(hostname[, rrtype], callback)//将一个域名（如 ‘runoob.com’）解析为一个 rrtype 指定记录类型的数组。4 dns.resolve4(hostname, callback)//和 dns.resolve() 类似, 仅能查询 IPv4 (A 记录）。 addresses IPv4 地址数组 (比如，[‘74.125.79.104’, ‘74.125.79.105’, ‘74.125.79.106’]）。5 dns.resolve6(hostname, callback)//和 dns.resolve4() 类似， 仅能查询 IPv6( AAAA 查询）6 dns.resolveMx(hostname, callback)//和 dns.resolve() 类似, 仅能查询邮件交换(MX 记录)。7 dns.resolveTxt(hostname, callback)//和 dns.resolve() 类似, 仅能进行文本查询 (TXT 记录）。 addresses 是 2-d 文本记录数组。(比如，[ [‘v=spf1 ip4:0.0.0.0 ‘, ‘~all’ ] ]）。 每个子数组包含一条记录的 TXT 块。根据使用情况可以连接在一起，也可单独使用。8 dns.resolveSrv(hostname, callback)//和 dns.resolve() 类似, 仅能进行服务记录查询 (SRV 记录）。 addresses 是 hostname可用的 SRV 记录数组。 SRV 记录属性有优先级（priority），权重（weight）, 端口（port）, 和名字（name） (比如，[{‘priority’: 10, ‘weight’: 5, ‘port’: 21223, ‘name’: ‘service.example.com’}, …]）。9 dns.resolveSoa(hostname, callback)//和 dns.resolve() 类似, 仅能查询权威记录(SOA 记录）。10 dns.resolveNs(hostname, callback)//和 dns.resolve() 类似, 仅能进行域名服务器记录查询(NS 记录）。 addresses 是域名服务器记录数组（hostname 可以使用） (比如, [‘ns1.example.com’, ‘ns2.example.com’]）。11 dns.resolveCname(hostname, callback)//和 dns.resolve() 类似, 仅能进行别名记录查询 (CNAME记录)。addresses 是对 hostname 可用的别名记录数组 (比如，, [‘bar.example.com’]）。12 dns.reverse(ip, callback)//反向解析 IP 地址，指向该 IP 地址的域名数组。13 dns.getServers()//返回一个用于当前解析的 IP 地址数组的字符串。14 dns.setServers(servers)//指定一组 IP 地址作为解析服务器。 rrtypesdns.resolve()方法中有效的rrtypes值：123456789&apos;A&apos; IPV4 地址, 默认&apos;AAAA&apos; IPV6 地址&apos;MX&apos; 邮件交换记录&apos;TXT&apos; text 记录&apos;SRV&apos; SRV 记录&apos;PTR&apos; 用来反向 IP 查找&apos;NS&apos; 域名服务器记录&apos;CNAME&apos; 别名记录&apos;SOA&apos; 授权记录的初始值 错误码每次 DNS 查询都可能返回以下错误码:123456789101112131415161718192021222324dns.NODATA: 无数据响应。dns.FORMERR: 查询格式错误。dns.SERVFAIL: 常规失败。dns.NOTFOUND: 没有找到域名。dns.NOTIMP: 未实现请求的操作。dns.REFUSED: 拒绝查询。dns.BADQUERY: 查询格式错误。dns.BADNAME: 域名格式错误。dns.BADFAMILY: 地址协议不支持。dns.BADRESP: 回复格式错误。dns.CONNREFUSED: 无法连接到 DNS 服务器。dns.TIMEOUT: 连接 DNS 服务器超时。dns.EOF: 文件末端。dns.FILE: 读文件错误。dns.NOMEM: 内存溢出。dns.DESTRUCTION: 通道被摧毁。dns.BADSTR: 字符串格式错误。dns.BADFLAGS: 非法标识符。dns.NONAME: 所给主机不是数字。dns.BADHINTS: 非法HINTS标识符。dns.NOTINITIALIZED: c c-ares 库尚未初始化。dns.LOADIPHLPAPI: 加载 iphlpapi.dll 出错。dns.ADDRGETNETWORKPARAMS: 无法找到 GetNetworkParams 函数。dns.CANCELLED: 取消 DNS 查询。 实例创建 main.js 文件，代码如下所示：12345678910var dns = require('dns');dns.lookup('www.github.com',function onLookup(err, address, family)&#123; console.log('ip 地址：', address); dns.reverse(address, function(err, hostname)&#123; if (err) &#123; console.log(err.stack); &#125; console.log('反向解析' + address + ':' + JSON.stringify(hostname)); &#125;);&#125;); 执行以上代码，结果如下所示：12address: 192.30.252.130reverse for 192.30.252.130: [&quot;github.com&quot;] Node.js Domain 模块Node.js Domain(域) 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的异常。引入 Domain 模块 语法格式如下：1var domain = require(\"domain\") domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即推出，与process.on(‘uncaughtException’)不同。Domain 模块可分为隐式绑定和显式绑定：1、隐式绑定: 把在domain上下文中定义的变量，自动绑定到domain对象2、显式绑定: 把不是在domain上下文中定义的变量，以代码的方式绑定到domain对象 方法：1 domain.run(function)//在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。2 domain.add(emitter)//显式的增加事件3 domain.remove(emitter)//删除事件。4 domain.bind(callback)//返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数被时，所有被抛出的错误都会被导向到这个域的 error 事件。5 domain.intercept(callback)//和 domain.bind(callback) 类似。除了捕捉被抛出的错误外，它还会拦截 Error 对象作为参数传递到这个函数。6 domain.enter()//进入一个异步调用的上下文，绑定到domain。7 domain.exit()//退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。8 domain.dispose()//释放一个domain对象，让node进程回收这部分资源。9 domain.create()//返回一个domain对象。 事件：1 domain.menbers//已加入domain对象的域定时器和事件发射器的数组。 实例创建 main.js 文件，代码如下所示：123456789101112131415161718192021222324252627var EventEmitter = require(\"events\").EventEmitter;var domain = require(\"domain\");var emitter1 = new EventEmitter();// 创建域var domain1 = domain.create();domain1.on('error', function(err)&#123; console.log(\"domain1 处理这个错误 (\"+err.message+\")\");&#125;);// 显式绑定domain1.add(emitter1);emitter1.on('error',function(err)&#123; console.log(\"监听器处理此错误 (\"+err.message+\")\");&#125;);emitter1.emit('error',new Error('通过监听器来处理'));emitter1.removeAllListeners('error');emitter1.emit('error',new Error('通过 domain1 处理'));var domain2 = domain.create();domain2.on('error', function(err)&#123; console.log(\"domain2 处理这个错误 (\"+err.message+\")\");&#125;);// 隐式绑定domain2.run(function()&#123; var emitter2 = new EventEmitter(); emitter2.emit('error',new Error('通过 domain2 处理')); &#125;);domain1.remove(emitter1);emitter1.emit('error', new Error('转换为异常，系统将崩溃!')); 执行以上代码，结果如下所示:123456789101112131415监听器处理此错误 (通过监听器来处理)domain1 处理这个错误 (通过 domain1 处理)domain2 处理这个错误 (通过 domain2 处理)events.js:72 throw er; // Unhandled &apos;error&apos; event ^Error: 转换为异常，系统将崩溃! at Object.&lt;anonymous&gt; (/www/node/main.js:40:24) at Module._compile (module.js:456:26) at Object.Module._extensions..js (module.js:474:10) at Module.load (module.js:356:32) at Function.Module._load (module.js:312:12) at Function.Module.runMain (module.js:497:10) at startup (node.js:119:16) at node.js:929:3","tags":[{"name":"node","slug":"node","permalink":"https://jermyo.github.io/JerBlog/tags/node/"}]},{"title":"Node.js GET/POST请求(12)","date":"2016-06-29T07:38:20.000Z","path":"2016/06/29/Node.js GET POST请求/","text":"12、Node.js GET/POST请求获取GET请求内容由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。node.js中url模块中的parse函数提供了这个功能。1234567var http = require('http');var url = require('url');var util = require('util');http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end(util.inspect(url.parse(req.url, true)));&#125;).listen(3000); 在浏览器中访问http://localhost:3000/user?name=w3c&amp;email=w3c@w3cschool.cc 然后查看返回结果:12345678910111213Url &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '?name=w3c&amp;email=w3c@w3cschool.cc', query: &#123; name: 'w3c', email: 'w3c@w3cschool.cc' &#125;, pathname: '/user', path: '/user?name=w3c&amp;email=w3c@w3cschool.cc', href: '/user?name=w3c&amp;email=w3c@w3cschool.cc' &#125; 获取POST请求内容POST请求的内容全部的都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所有node.js默认是不会解析请求体的， 当你需要的时候，需要手动来做。12345678910111213var http = require('http');var querystring = require('querystring');var util = require('util');http.createServer(function(req, res)&#123; var post = '';//定义了一个post变量，用于暂存请求体的信息 req.on('data',function(chunk)&#123;//通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中 post += chunk; &#125;); req.on('end',function()&#123;//在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。 post = querystring.parse(post); res.end(util.inspect(post)); &#125;);&#125;).listen(3000);","tags":[{"name":"node","slug":"node","permalink":"https://jermyo.github.io/JerBlog/tags/node/"}]},{"title":"Node.js常用工具(10)","date":"2016-06-29T00:10:03.000Z","path":"2016/06/29/Node.js 常用工具/","text":"10、Node.js 常用工具util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。 util.inheritsutil.inherits(constructor, superConstructor)//是一个实现对象间原型继承 的函数。JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。在这里我们只介绍util.inherits 的用法，示例如下：12345678910111213141516171819202122var util = require('util');function Base() &#123; this.name = 'base'; this.base = 1991; this.sayHello = function() &#123; console.log('Hello ' + this.name); &#125;;&#125; Base.prototype.showName = function()&#123; console.log(this.name);&#125;;function Sub() &#123; this.name = 'sub';&#125;util.inherits(Sub, Base);var objBase = new Base();objBase.showName();objBase.sayHello();console.log(objBase);var objSub = new Sub();objSub.showName();console.log(objSub); 我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：12345base Hello base &#123; name: &apos;base&apos;, base: 1991, sayHello: [Function] &#125; sub &#123; name: &apos;sub&apos; &#125; 注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。同时，在原型中定义的属性不会被console.log 作 为对象的属性输出. util.inspectutil.inspect(object,[showHidden],[depth],[colors])//是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。-showHidden//是一个可选参数，如果值为 true，将会输出更多隐藏信息。-depth//表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。-colors//如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。12345678910111213141516171819202122var util = require('util');function Person()&#123; this.name = 'byvoid'; this.toString = function()&#123; return this.name; &#125;;&#125;var obj = new Person();console.log(util.inspect(obj));console.log(util.inspect(obj,true));//运行结果是： Person &#123; name: 'byvoid', toString: [Function] &#125;Person &#123; name: 'byvoid', toString: &#123; [Function] [length]: 0, [name]: '', [arguments]: null, [caller]: null, [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125; util.isArrayutil.isArray(object)//如果给定的参数 “object” 是一个数组返回true，否则返回false。1234var util = require('util');util.isArray([]);// trueutil.isArray(new Array);// trueutil.isArray(&#123;&#125;);// false util.isRegExputil.isRegExp(object)//如果给定的参数 “object” 是一个正则表达式返回true，否则返回false。1234var util = require('util');util.isRegExp(/some regexp/);// trueutil.isRegExp(new RegExp('another regexp'));// trueutil.isRegExp(&#123;&#125;);// false util.isDateutil.isDate(object)// 如果给定的参数 “object” 是一个日期返回true，否则返回false。1234var util = require('util');util.isDate(new Date());// trueutil.isDate(Date());// false (without 'new' returns a String)util.isDate(&#123;&#125;);// false util.isErrorutil.isError(object)// 如果给定的参数 “object” 是一个错误对象返回true，否则返回false。1234var util = require('util');util.isError(new Error());// trueutil.isError(new TypeError());// trueutil.isError(&#123; name: 'Error', message: 'an error occurred' &#125;);// false","tags":[{"name":"node","slug":"node","permalink":"https://jermyo.github.io/JerBlog/tags/node/"}]},{"title":"Node.js 路由(8)","date":"2016-06-28T10:55:08.000Z","path":"2016/06/28/Node.js 路由/","text":"8、Node.js 路由我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码。因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。12345678910111213 url.parse(string).query | url.parse(string).pathname | | | | | ------ -------------------http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring(string)[\"foo\"] | | querystring(string)[\"hello\"] 当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：1234567891011121314var http = require(\"http\");var url = require(\"url\");function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \"received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 现在我们可以来编写路由了，建立一个名为router.js的文件:1234function route(pathname)&#123; console.log(\"About to route a request for \" + pathname);&#125;exports.route = route; 在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来(我们将使用依赖注入的方式较松散地添加路由模块)。首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去：123456789101112131415var http = require(\"http\");var url = require(\"url\");function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \"received.\"); route(pathname);//路由函数 response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：123var server = require(\"./server\");var router = require(\"./router\");server.start(router.route); 现在启动应用（node index.js），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：1234node index.jsRequest for /foo received.About to route a request for /foo//以上输出已经去掉了比较烦人的`/favicon.ico`请求相关的部分。","tags":[{"name":"node","slug":"node","permalink":"https://jermyo.github.io/JerBlog/tags/node/"}]},{"title":"Node.js创建第一个应用(1)","date":"2016-06-27T03:55:07.000Z","path":"2016/06/27/Node.js创建第一个应用/","text":"1、Node.js创建第一个应用1.1、创建服务器使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。实例如下，在项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：1234567891011var http = require(\"http\");//引入require模块http.createServer(function(require, response)&#123; //发送 HTTP 头部 //HTTP 状态值：200：OK //内容类型：text/plain response.writeHead(200, &#123;'Content-Type':'text/plain'&#125;); //发送响应数据：“Hello World” response.end('Hello World\\n');&#125;).listen(8888);//终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 使用 node 命令执行以上的代码：12node server.jsServer running at http://127.0.0.1:8888/ 接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 “Hello World” 的网页。","tags":[{"name":"node","slug":"node","permalink":"https://jermyo.github.io/JerBlog/tags/node/"}]},{"title":"Hexo博客优化——站内搜索、版权、IE8兼容","date":"2016-05-25T02:03:15.000Z","path":"2016/05/25/Hexo博客优化--站内搜索、版权、IE8兼容/","text":"1.添加Hexo的swiftype站内搜索先去swiftype官网注册一个账号,然后根据指引建立好自己网站对应的索引。步骤： Create an engine—&gt; Create a search engine &gt;(standard web crawler)—&gt; WEBSITE URL下填写你的网站地址：如：http://chaooo.github.io—&gt; ENGINE NAME自己取一个名字：如：chaooo—&gt; 然后他开始抓取你网站的数据。—&gt; 完成后，可以点击Content去看看抓了些什么数据，然后可以自己删除不想要的数据。（可选）—&gt; 点击Install Search复制里面的代码： 然后在themes\\landscape\\layout\\_partial\\after-footer.ejs在最后加上刚复制的代码：12345678&lt;script type=\"text/javascript\"&gt; (function(w,d,t,u,n,s,e)&#123;w['SwiftypeObject']=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st'); _st('install','Hvy4-e-Ew4x8PR6Let84','2.0.0');&lt;/script&gt; 在themes\\landscape\\_config.yml末尾添加如下代码：12swift_search: enable: true 然后到themes\\landscape\\layout\\_partial\\header.ejs中找到：&lt;div id=&quot;search-form-wrap&quot;&gt;...&lt;/div&gt;刪除里面的內容，插入如下代码：123456&lt;div id=\"search-form-wrap\"&gt; &lt;form action=\"\" method=\"get\" accept-charset=\"UTF-8\" class=\"search-form\"&gt; &lt;input autocapitalize=\"off\" autocorrect=\"off\" autocomplete=\"off\" name=\"q\" results=\"0\" id=\"search\" maxlength=\"20\" placeholder=\"Search\" style=\"border:none;background:none;width:161px;height:30px;line-height:30px;padding:0px 11px 0px 28px;\" class=\"st-default-search-input search-form-input\" type=\"text\"&gt; &lt;button type=\"submit\" class=\"search-form-submit\"&gt;&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; 然后到themes\\landscape\\source\\css\\_partial\\header.styl找到#search-form-wrap对其样式微调，大概在118行，修改后的值：1234567891011121314151617#search-form-wrap position: absolute top: 14px width: 200px height: 30px right: 35px opacity: 0 visibility: hidden transition: 0.2s ease-out transform: scale(.5) translate(94px, 0) &amp;.on opacity: 1 visibility: visible transform: scale(1) translate(0, 0) @media mq-mobile width: 80% right: -80% 然后到themes\\landscape\\source\\css\\_partial\\header.styl找到.nav-icon，大概在81行，在其后面添加(z-index: 1)：1234567891011.nav-icon @extend $nav-link font-family: font-icon text-align: center font-size: font-size width: font-size height: font-size padding: 20px 15px position: relative cursor: pointer z-index: 1 注意：在使用中我发现swiftype搜索框在IE和火狐浏览器根本不能唤醒搜狗输入法的中文输入，必须要先输入一个英文字母才能输入中文，我在swiftype官网测试的swiftype搜索框也一样。（我分别测试了Chrome–v49，Firefox Developer Edition–v47，IE11/IE10/IE9,结果只有Chrome能唤起搜狗中文。） 2. 页尾版权信息修改在themes\\landscape\\layout\\_partial\\footer.ejs中，第6行开始，修改其为居中对齐，添加网站地图、订阅、联系博主链接：12345&lt;div id=\"footer-info\" class=\"inner\" style=\"text-align:center;\"&gt; Copyright &amp;copy; &lt;%= date(new Date(), 'YYYY') %&gt; &lt;%= config.author || config.title %&gt;&lt;br&gt; &lt;%= __('powered_by') %&gt; &lt;a href=\"http://hexo.io/\" target=\"_blank\"&gt;Hexo&lt;/a&gt;&lt;br&gt; &lt;a href=\"/baidusitemap.xml\"&gt;网站地图&lt;/a&gt;&amp;nbsp; &amp;nbsp;|&amp;nbsp; &amp;nbsp;&lt;a href=\"/atom.xml\"&gt;订阅本站&lt;/a&gt;&amp;nbsp; &amp;nbsp;|&amp;nbsp; &amp;nbsp;&lt;a href=\"mailto:zhenggchaoo@gmail.com\" target=\"_blank\"&gt;联系博主&lt;/a&gt; &lt;/div&gt; 3. 对于低版本IE布局微调3.1 加入低版本IE浏览器提醒Hexo主题大多都只完美支持IE9及以上版本的浏览器，低版本IE会影响网站体验，所以要提示浏览者及时更换现代浏览器，在themes\\landscape\\layout\\_partial\\header.ejs中找到&lt;div id=&quot;header-outer&quot; class=&quot;outer&quot;&gt;&lt;/div&gt;以其为父元素添加：1234567891011121314151617&lt;!--[if lt IE 9]&gt; &lt;style&gt; .hid-ltIE9&#123;position:absolute;bottom:0;z-index:999;width:100%;line-height:46px;color:#7b1a00;font-size:14px;text-align:center;background:#fff3c8;border-radius:4px;border:1px solid #;text-shadow:0 1px #fff;-webkit-box-shadow:0 -1px 4px #ccc inset;box-shadow:0 -1px 4px #ccc inset;border:1px solid #ccc;&#125; .hid-ltIE9 a&#123;color:#258fb8;text-decoration:none;&#125; .hid-ltIE9 a:hover&#123;text-decoration:underline;&#125; .hid-exclamation-triangle,.hid-chrome,.hid-firefox&#123;font:normal normal normal 14px/1 FontAwesome;display:inline-block;width:30px;height:30px;font-size:14px;text-align:center;&#125; .hid-exclamation-triangle:before&#123;content:\"\\f071\";&#125; .hid-chrome:before&#123;content:\"\\f268\";&#125; .hid-firefox:before&#123;content:\"\\f269\";&#125; &lt;/style&gt; &lt;p class=\"hid-ltIE9\"&gt; &lt;i class=\"hid-exclamation-triangle\" aria-hidden=\"true\"&gt;&lt;/i&gt;重要提示：您当前使用的浏览器版本过低，可能存在安全风险！想要更好的体验，建议升级浏览器： &lt;a href=\"https://www.google.cn/intl/zh-CN/chrome/browser/desktop/\" title=\"谷歌Chrome浏览器\"&gt;&lt;i class=\"hid-chrome\" aria-hidden=\"true\"&gt;&lt;/i&gt; Chrome&lt;/a&gt;、 &lt;a href=\"http://www.firefox.com.cn/download/\"title=\"火狐Firefox浏览器\"&gt;&lt;i class=\"hid-firefox\" aria-hidden=\"true\"&gt;&lt;/i&gt;Firefox&lt;/a&gt; &lt;/p&gt;&lt;![endif]--&gt; 这样，现代浏览器都不会解析这段代码，直到IE8及其版本的浏览器才会显示。 3.2 (对于旧IE)header与footer布局微调发现博客在IE8及其版本的浏览器显示很多样式都乱掉了，特别是头部header，毕竟还有不少人用的低版本浏览器，平常工作中也要求做到兼容到IE8，所以这里只做稍微调。在themes\\landscape\\layout\\_partial\\header.ejs中，把&lt;header id=&quot;header&quot;&gt;&lt;/div&gt;用下面的代码包起来：12345&lt;!--[if lt IE 9]&gt;&lt;div id=\"header\"&gt;&lt;![endif]--&gt;&lt;header id=\"header\"&gt; //....其他代码&lt;/header&gt;&lt;!--[if lt IE 9]&gt;&lt;/div&gt;&lt;![endif]--&gt; 在themes\\landscape\\layout\\_partial\\footer.ejs中，把&lt;header id=&quot;footer&quot;&gt;&lt;/div&gt;用下面的代码包起来：12345&lt;!--[if lt IE 9]&gt;&lt;div id=\"footer\"&gt;&lt;![endif]--&gt;&lt;footer id=\"footer\"&gt; //....其他代码&lt;/footer&gt;&lt;!--[if lt IE 9]&gt;&lt;/div&gt;&lt;![endif]--&gt; 虽然这样调整并不高明，但能使其在IE8下显示效果大体上还能接受。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jermyo.github.io/JerBlog/tags/hexo/"}]},{"title":"Hexo博客优化——库、字体、收录、统计","date":"2016-05-24T03:22:56.000Z","path":"2016/05/24/Hexo博客优化--库、字体、收录、统计/","text":"1. jQuery 库的优化landscape默认是使用Google jQuery 库，但在国内速度不是很理想，这里把它换成新浪的，在themes\\landscape\\layout\\_partial\\after-footer.ejs17行：1&lt;script src=\"//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js\"&gt;&lt;/script&gt; 替换为如下代码：12345678&lt;script src=\"http://lib.sinaapp.com/js/jquery/2.0.3/jquery-2.0.3.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;//&lt;![CDATA[if (typeof jQuery == 'undefined') &#123; document.write(unescape(\"%3Cscript src='/js/jquery-2.0.3.min.js' type='text/javascript'%3E%3C/script%3E\"));&#125;// ]]&gt;&lt;/script&gt; 这里不但将 Google 的 jQuery 替换成了 SAE 的，随后还进行了一个判断，如果获取新浪的 jQuery 失败，则使用本网站自己的 jQuery。为了让这段代码有效，我们要去 jQuery 官方下载合适版本的 jQuery 并将其放到 themes/landscape/source/js/目录下，命名为 jquery-2.0.3.min.js。还有一点需要特别注意，那就是 jQuery 这个文件在 hexo 生成博客时会被解析，因此一定要将 jQuery 文件开头处的 //@ sourceMappingURL=jquery-2.0.3.min.map 这一行代码删去，否则会导致博客无法生成。 2. 字体优化2.1跨平台字体优化为了能在各个平台上都显示令人满意的字体，我们要修改CSS文件中的字体设置，列出多个备选的字体，操作系统会依次尝试，使用系统中已安装的字体。我们要修改的是themes/landscape/source/css/_variables.styl这一文件，将其中第22行:1font-sans = \"Helvetica Neue\", Helvetica, Arial, sans-serif 改成如下内容：1font-sans = Tahoma, \"Helvetica Neue\", Helvetica, \"Hiragino Sans GB\", \"Microsoft YaHei Light\", \"Microsoft YaHei\", \"Source Han Sans CN\", \"WenQuanYi Micro Hei\", Arial, sans-serif 其中海维提卡（Helvetica）、Arial是英文字体，前者一般存在于苹果电脑和移动设备上，后者一般存在于Windows系统中。冬青黑体（Hiragino Sans GB）、思源黑体（Source Han Sans CN）、文泉驿米黑（WenQuanYi Micro Hei）是中文字体，冬青黑体从OS X 10.6开始集成在苹果系统中，文泉驿米黑在Linux的各大发行版中均较为常见，而思源黑体是近期Google和Adobe合作推出的一款开源字体，很多电脑上也安装了这一字体。这样一来，在绝大部分操作系统中就可以显示美观的字体了。 2.2代码等宽字体优化Hexo默认的等宽字体是Google的Source Code Pro，这里把它换成360的，在themes/landscape/layout\\_partial\\head.ejs 第31行:1&lt;link href=\"//fonts.googleapis.com/css?family=Source+Code+Pro\" rel=\"stylesheet\" type=\"text/css\"&gt; 改成如下内容：1&lt;link href=\"http://fonts.useso.com/css?family=Source+Code+Pro\" rel=\"stylesheet\" type=\"text/css\"&gt; 3. hexo提交搜索引擎（百度+谷歌）3.1 确认博客是否被收录在百度或者谷歌上面输入下面格式来判断，如果能搜索到就说明被收录，否则就没有，用你的域名替代我的http:chaooo.github.io1site:chaooo.github.io 3.2 验证网站两个搜索引擎入口：Google搜索引擎提交入口、百度搜索引擎入口。不管谷歌还是百度都要先添加域名，然后验证网站，这里统一都使用文件验证，就是下载对应的html文件，放到域名根目录下，也就收博客根目录下的source/下面 。然后部署到服务器,输入地址：http://chaooo.github.io/google4cc3eef6ff5975bf.html和http://chaooo.github.io/baidu_verify_wjJ25Q3cv2.html能访问到就可以点验证按钮(按照谷歌或百度的引导步骤就好)。注意：若出现验证失败，则是因为hexo编译文件时，会给下载的HTML文件中添加其他的内容，导致验证失败。则需要在Github里手动修改验证HTML文件，或者不编译。我的做法是，删除根目录source/下面刚拷贝的两个文件，和编译后生成的public/下的两个同名文件（若细心会注意到source/和public/下的两个同名文件大小不一样）。然后重新执行：1hexo generate -d 现在重新验证就通过了。 3.3 安装 RSS(订阅) 和 sitemap(网站地图) 插件123$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 修改 hexo_config.yml 站点配置，添加：1234567891011121314151617#ExtensionsPlugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 部署后,访问 chaooo.github.io/sitemap.xml 和 chaooo.github.io/baidusitemap.xml,就能看到有内容且第一行为:该 XML 文件并未包含任何关联的样式信息。文档树显示如下。,就说明成功了。RSS 也差不多，访问 chaooo.github.io/atom.xml ，能看到订阅信息。注意：把chaooo.github.io换成你自己的个人域名（订阅是顺带安装的，也可以后在安装）。 3.4 让谷歌收录我们的博客谷歌操作比较简单，就是向Google站长工具提交sitemap。登录Google账号，添加了站点验证通过后，选择站点，之后在抓取——站点地图中就能看到添加/测试站点地图,然后输入sitemap.xml点击提交。 3.5 让百度收录我们的博客正常情况，是要等百度爬虫来爬到你的网站，才会被收录。但是github屏蔽了百度爬虫目前，所以我们要主动出击，我们自己把网站提交给百度。这就要使用到百度站长平台。1.进入站点管理，找到网页抓取——链接提交——详情点进去。一般主动提交比手动提交效果好，这里介绍主动提交的两种简单的方法 3.5.1 sitemap提交直接点击sitemap填写数据文件地址：chaooo.github.io/baidusitemap.xml,输入验证码提交。 3.5.2 自动推送自动推送很简单，就是在你代码里面嵌入自动推送JS代码，在页面被访问时，页面URL将立即被推送给百度，可将代码添加到\\themes\\landscape\\layout\\_partial\\after_footer.ejs中的最下面就行。代码如下：1234567891011121314&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; 百度链接提交主动推送后不收录的原因 4. 开启谷歌统计(google analysis)先到google analysis注册服务，注册时，需要正确填写 网站的URL。注册成功后，会得到一个跟踪ID，以及一段跟踪代码。12345678910// 跟踪 ID// UA-58387143-1&lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()&#123; (i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) &#125;)(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-58387143-1', 'auto'); ga('send', 'pageview');&lt;/script&gt; 到\\themes\\landscape\\layout\\_config.yml中,将google analysis打开：123google_analytics: enable: true id: UA-58387143-1 #刚注册获取的ID 如果设置不起作用，检查在themes\\pacman\\layout\\_partial\\下有没有google_analytics.ejs ，有的话就在\\themes\\landscape\\layout\\_partial\\head.ejs的&lt;/head&gt;之前，添加下面代码试试：1&lt;%- partial('google_analytics') %&gt; 若themes\\pacman\\layout\\_partial\\不存在google_analytics.ejs 文件，就手动创建：123456789101112&lt;% if (theme.google_analytics)&#123; %&gt;&lt;!-- Google Analytics --&gt;&lt;script type=\"text/javascript\"&gt;(function(i,s,o,g,r,a,m)&#123;i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)&#125;)(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', '&lt;%= theme.google_analytics %&gt;', 'auto');ga('send', 'pageview');&lt;/script&gt;&lt;!-- End Google Analytics --&gt;&lt;% &#125; %&gt; 最笨的方法就是删除google_analytics.ejs和刚在_config.yml配置google analysis的几行代码，直接从注册来的代码拷贝到\\themes\\landscape\\layout\\_partial\\head.ejs的&lt;/head&gt;之前。 5. 文章永久链接默认文章链结是以: http://chaooo.github.io/2016/05/24/文章标题/ 的格式，末尾没有.html结尾，有点动态页面的感觉，好像对搜索引擎不太友好，于是可以修改根目录下的 _config.yml 文件里:1permalink: :year/:month/:day/:title/ 改为：1permalink: :year/:month/:day/:title.html 最后浏览器访问就是http://chaooo.github.io/2016/05/24/文章标题.html 的格式了。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jermyo.github.io/JerBlog/tags/hexo/"}]},{"title":"Hexo博客优化——主题、分享、评论、微博秀","date":"2016-05-23T06:30:13.000Z","path":"2016/05/23/Hexo博客优化--主题、分享、评论、微博秀/","text":"继上一篇Hexo3.2+GitHub搭建静态博客。 1.主题Hexo提供了很多主题，具体可参见Themes|Hexo，这里我选择默认主题landscape(此主题默认已安装)。 1.1安装主题将Git Shell切换到根目录，执行下列命令，将主题下载到themes/spfk目录下：1$ git clone https://github.com/hexojs/hexo-theme-landscape.git themes/landscape 获取landscape主题的最新版本：12$ cd themes/landscape$ git pull 修改在根目录下_config.yml 配置：1theme: landscape 2.修改添加分享链接2.1原生分享的修改在themes\\landscape\\source\\js\\script.js中，57行 &lt;div class=&quot;article-share-links&quot;&gt;下面的四个链接就是 Facebook 等社交网站的分享链接。将其替换或添加如下代码，即可实现分享到国内社交网站：1234'&lt;a href=\"http://service.weibo.com/share/share.php?&amp;title=好东西就要一起分享&amp;language=zh_cn&amp;url=' + encodedUrl + '\" class=\"article-share-sina\" target=\"_blank\" title=\"微博\"&gt;&lt;/a&gt;','&lt;a href=\"http://share.renren.com/share/buttonshare.do?link=' + encodedUrl + '\" class=\"article-share-renren\" target=\"_blank\" title=\"人人\"&gt;&lt;/a&gt;','&lt;a href=\"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + encodedUrl + '\" class=\"article-share-qq\" target=\"_blank\" title=\"QQ空间\"&gt;&lt;/a&gt;','&lt;a href=\"http://qr.liantu.com/api.php?text=' + encodedUrl + '\" class=\"article-share-wechat\" target=\"_blank\" title=\"微信\"&gt;&lt;/a&gt;', 同时，还需要替换图标。本主题使用 Font Awesome 来显示图标，但内置的 Font Awesome 版本较旧，无法显示 QQ、微信等图标，所以，需要下载最新版 Font Awesome，替换掉 themes\\landscape\\source\\css\\fonts中相关文件，并在themes\\landscape\\source\\css\\_variables.styl中27行的 font-icon-version 修改为最新的 Font Awesome 版本号。 然后，在 themes\\landscape\\source\\css\\_partial\\article.styl 中，找到四段以 .article-share-***开头的代码（273行起），添加如下内容：12345678910111213141516171819202122232425262728293031.article-share-sina @extend $article-share-link &amp;:before content: \"\\f18a\" &amp;:hover background: color-sina text-shadow: 0 1px darken(color-sina, 20%).article-share-qq @extend $article-share-link &amp;:before content: \"\\f1d6\" &amp;:hover background: color-qq text-shadow: 0 1px darken(color-qq, 20%).article-share-renren @extend $article-share-link &amp;:before content: \"\\f18b\" &amp;:hover background: color-renren text-shadow: 0 1px darken(color-renren, 20%).article-share-wechat @extend $article-share-link &amp;:before content: \"\\f1d7\" &amp;:hover background: color-wechat text-shadow: 0 1px darken(color-wechat, 20%) 最后，找到 themes\\landscape\\source\\css\\_variables.styl 中 Colors 部分（16行），最后四行分别为社交网站图标的背景色，可根据这些网站的主题色修改。1234color-sina = #ff8140color-qq = #ffcc33color-renren = #227dc5color-wechat = #44b549 2.2加入百度分享首先在_config.yml中增加bdshare_shortname: 你站点的short_name，这里的short_name也就是你的二级域名。1bdshare_shortname: http://chaooo.github.io/ 在百度分享获取代码后，代码可分为两部分。在themes\\landscape\\layout\\_partial\\article.ejs中第26行插入第一段代码并添加判断条件，若当前页为文章展开页则显示百度分享框，若是缩略则采用原生分享链接，避免百度分享框获取的 URL 错误：12345678&lt;% if ((page.layout == 'post'|| page.layout == 'page'))&#123; %&gt;&lt;div class=\"bdsharebuttonbox\"&gt;&lt;span style=\"float:left;line-height:16px;height:16px;margin: 6px 6px 6px 0;\"&gt;分享到：&lt;/span&gt;&lt;a title=\"分享到新浪微博\" href=\"#\" class=\"bds_tsina\" data-cmd=\"tsina\"&gt;&lt;/a&gt;&lt;a title=\"分享到QQ空间\" href=\"#\" class=\"bds_qzone\" data-cmd=\"qzone\"&gt;&lt;/a&gt;&lt;a title=\"分享到微信\" href=\"#\" class=\"bds_weixin\" data-cmd=\"weixin\"&gt;&lt;/a&gt;&lt;a title=\"分享到人人网\" href=\"#\" class=\"bds_renren\" data-cmd=\"renren\"&gt;&lt;/a&gt;&lt;a title=\"分享到Facebook\" href=\"#\" class=\"bds_fbook\" data-cmd=\"fbook\"&gt;&lt;/a&gt;&lt;a title=\"分享到一键分享\" href=\"#\" class=\"bds_mshare\" data-cmd=\"mshare\"&gt;&lt;/a&gt;&lt;a href=\"#\" class=\"bds_more\" data-cmd=\"more\"&gt;&lt;/a&gt;&lt;/div&gt;&lt;% &#125; else &#123; %&gt;&lt;a data-url=\"&lt;%- post.permalink %&gt;\" data-id=\"&lt;%= post._id %&gt;\" class=\"article-share-link\"&gt;&lt;%= __('share') %&gt;&lt;/a&gt;&lt;% &#125; %&gt;&lt;!-- Baidu Share Start --&gt;&lt;script&gt;window._bd_share_config=&#123;\"common\":&#123;\"bdSnsKey\":&#123;&#125;,\"bdText\":\"好东西就要一起分享~\",\"bdMini\":\"2\",\"bdMiniList\":[\"mshare\",\"qzone\",\"tsina\",\"weixin\",\"sqq\",\"douban\",\"tqq\",\"renren\",\"kaixin001\",\"tqf\",\"linkedin\",\"ty\",\"fbook\",\"twi\",\"copy\",\"print\"],\"bdPic\":\"\",\"bdStyle\":\"1\",\"bdSize\":\"16\"&#125;,\"share\":&#123;&#125;,\"image\":&#123;\"viewList\":[\"mshare\",\"weixin\",\"qzone\",\"tsina\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"&#125;,\"selectShare\":&#123;\"bdContainerClass\":null,\"bdSelectMiniList\":[\"mshare\",\"weixin\",\"qzone\",\"tsina\"]&#125;&#125;;with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];&lt;/script&gt;&lt;!-- Baidu Share End --&gt; 3.加入多说评论首先在_config.yml中增加duoshuo_shortname: 你站点的short_name，这里的short_name也就是你的二级域名。1duoshuo_shortname: http://chaooo.github.io/ 如果使用的是默认的landscape主题只需要修改themes\\landscape\\layout\\_partial\\article.ejs中的disqus评论：1234567&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt; &lt;section id=\"comments\"&gt; &lt;div id=\"disqus_thread\"&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=\"//disqus.com/?ref_noscript\"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt; &lt;% &#125; %&gt; 改为多说评论：1234567891011121314151617181920&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;&lt;section id=\"comments\"&gt;&lt;!-- 多说评论框 start --&gt; &lt;div class=\"ds-thread\" data-thread-key=\"&lt;%= post.path %&gt;\" data-title=\"&lt;%= post.title %&gt;\" data-url=\"&lt;%= post.url %&gt;\"&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type=\"text/javascript\"&gt;var duoshuoQuery = &#123;short_name:\"chaooo\"&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); &lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt;&lt;/section&gt;&lt;% &#125; %&gt; 如果是其他主题，也只需要修改主题\\layout_partial\\comment.ejs注意多说的Thread Key一定不要改变，Thread Key相当于是识别码；如果改变了的话，评论清空。 4. 侧栏微博秀登录新浪微博开放平台来获取微博秀的代码，将其样式调整与主题一致，关掉各种边框和标题栏。然后新建themes/landscape/layout/_widget/weibo.ejs这个文件，将刚刚获取到的代码添加到这个文件中。最后编辑themes/landscape/_config.yml，在widgets:标签后面的适当位置添加- weibo。这样微博秀应该就可以显示在你的博客上了。123456&lt;div class=\"widget-wrap\"&gt; &lt;h3 class=\"widget-title\"&gt;微博&lt;/h3&gt; &lt;div class=\"widget\" style=\"padding: 0\"&gt; &lt;iframe width=\"100%\" height=\"400\" class=\"share_self\" frameborder=\"0\" scrolling=\"no\" src=\"http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=2&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,dddddd,555555,837f86,cccccc&amp;dpc=1\"&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/div&gt; 其中，&lt;iframe...&gt;&lt;/iframe&gt;为获取微博秀的代码。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jermyo.github.io/JerBlog/tags/hexo/"}]},{"title":"Hexo3.2+GitHub搭建静态博客","date":"2016-05-23T03:16:51.000Z","path":"2016/05/23/Hexo3-2-github搭建静态博客/","text":"开始之前在安装hexo之前，必须确认你已经安装了Node.js和Git。 1.创建GitHub仓库注册GitHub账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：chaooo.github.io，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。 2.配置Git设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：12$ git config --global user.name \"username\"$ git config --global user.email \"email@example.com\" 3.本地Git与GitHub建立联系这里介绍SSH的配置，先检查电脑是否已经有SSH1$ ls -al ~/.ssh 如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。输入以下指令后，一路回车就好：1$ ssh-keygen -t rsa -C \"emailt@example.com\" 然后键入以下指令：12$ ssh-agent -s$ ssh-add ~/.ssh/id_rsa 如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可：1$ ssh-agent bash 再重新输入指令：1$ ssh-add ~/.ssh/id_rsa 到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：1$ clip &lt; ~/.ssh/id_rsa.pub 在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH keyTitle自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。最后还是测试一下吧，键入以下命令：1$ ssh -T git@github.com 你可能会看到有警告，没事，输入“yes”就好。 4.初始化hexo文件夹到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt;12$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git$ mkdir Hexo-admin Hexo安装配置1.Hexo初始化进入Hexo-admin文件夹1$ cd Hexo-admin 接下来只需要使用 npm 即可完成 Hexo 的安装:1$ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:12$ hexo init$ npm install 接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。12$ hexo generate$ hexo server 输入Ctrl+C停止服务。 2.Hexo配置用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: repository: 到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/chaooo/chaooo.github.io.git branch: master 3.完成部署最后一步，快要成功了，键入指令：123$ npm install hexo-deployer-git --save$ hexo generate$ hexo deploy 输入弹出框的用户名与密码(首次使用git会弹出)。OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：chaooo.github.io/每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：123To https://github.com/chaooo/chaooo.github.io.git 7f3b50a..128a10d HEAD -&gt; masterINFO Deploy done: git 当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。 日常操作1.写文章执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。1$ hexo new [layout] \"文章标题\" #新建文章 然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout， 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:--- 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：12345title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories:tags:--- 文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。 2.提交每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。123$ git add .$ git commit -m \"...\"$ git push origin develop 然后才执行hexo generate -d发布网站到master分支上。1$ hexo generate -d 3.本地仓库丢失当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤： 3.1拷贝仓库1$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git 3.2配置Hexo在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:1234$ npm install -g hexo-cli$ npm install hexo$ npm install$ npm install hexo-deployer-git --save 小Tips:hexo 命令1234567891011121314hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo deploy -g #生成加部署hexo server -g #生成加预览#命令的简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jermyo.github.io/JerBlog/tags/hexo/"}]}]